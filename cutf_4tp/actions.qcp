/*======================================================
	ACTIONS.QC			Custom TeamFortress v3.2	

	(c) TeamFortress Software Pty Ltd	13/5/97
	(c) William Kerney			2/9/00
	(c) Craig Hauser				19/3/00
========================================================
Non Class-Specific Impulse Commands
=======================================================*/
// Prototypes
void() TeamFortress_Discard;
void() TeamFortress_SaveMe;
void(float inAuto) TeamFortress_ID;
void() TeamFortress_ReloadCurrentWeapon;

//CH dropitems
float() TeamFortress_DropItems;
void(entity Item, entity AP, float method) tfgoalitem_RemoveFromPlayer;

//=========================================================================
// Discard Command. Drops all ammo useless to the player's class.
void() TeamFortress_Discard =
{
	// Create a backpack
	newmis = spawn();
//CH to save space. Dont do class specific checks
//
//CH new setup, checks if you have weapon that uses that ammo
//and if you dont, throws it away
	if (self.playerclass != 0)
	{
		if (!(self.weapons_carried & 32 || self.weapons_carried & 64 || self.weapons_carried & 128 || self.weapons_carried & 256 || self.weapons_carried & 32768 || (self.cutf_items & 16 && self.weapons_carried & 8)))
			newmis.ammo_shells = self.ammo_shells;
		if (!(self.weapons_carried & 512 || self.weapons_carried & 8388608 || self.weapons_carried & 1024 || self.weapons_carried & 524288 || self.weapons_carried & 262144 || self.weapons_carried & 1048576)) //CH is it just me or are there not many nail weapons? //WK It's just you
			newmis.ammo_nails = self.ammo_nails;
		if (!(self.weapons_carried & 8192 || self.weapons_carried & 16384 || self.weapons_carried & 2048 || (self.cutf_items & 16 && self.weapons_carried & 8) || self.job & 32))
			newmis.ammo_rockets = self.ammo_rockets;
		//OfN old bug, WEAP_SUPERSHOTGUN if (!(self.cutf_items & #CUTF_CYBERAUG || self.cutf_items & #CUTF_HOLO || self.weapons_carried & #WEAP_LASERCANNON || self.weapons_carried & #WEAP_INCENDIARY || self.weapons_carried & #WEAP_LIGHTNING || self.weapons_carried & #WEAP_SUPER_SHOTGUN || self.weapons_carried & #WEAP_ASSAULT_CANNON || self.weapons_carried & #WEAP_DAEDALUS || (self.cutf_items & #CUTF_SENTRYGUN && self.weapons_carried & #WEAP_SPANNER) || (self.weapons_carried & #WEAP_SPANNER && self.tf_items & #NIT_TESLA) || (self.weapons_carried & #WEAP_SPANNER && self.tf_items & #NIT_SECURITY_CAMERA) || (self.weapons_carried & #WEAP_SPANNER && self.tf_items & #NIT_TELEPORTER)))
		//done -  FIXME: Add fieldgens
		//if (!(self.cutf_items & #CUTF_CYBERAUG || self.cutf_items & #CUTF_HOLO || self.weapons_carried & #WEAP_LASERCANNON || self.weapons_carried & #WEAP_INCENDIARY || self.weapons_carried & #WEAP_LIGHTNING || self.weapons_carried & #WEAP_AIRF || self.weapons_carried & #WEAP_ASSAULT_CANNON || self.weapons_carried & #WEAP_DAEDALUS || (self.cutf_items & #CUTF_SENTRYGUN && self.weapons_carried & #WEAP_SPANNER) || (self.weapons_carried & #WEAP_SPANNER && self.tf_items & #NIT_TESLA) || (self.weapons_carried & #WEAP_SPANNER && self.tf_items & #NIT_SECURITY_CAMERA) || (self.weapons_carried & #WEAP_SPANNER && self.tf_items & #NIT_TELEPORTER) || (self.weapons_carried & #WEAP_SPANNER && self.cutf_items & #CUTF_FIELDGEN)))
		//if (!(self.cutf_items & #CUTF_CYBERAUG || self.cutf_items & #CUTF_HOLO || self.weapons_carried & #WEAP_LASERCANNON || self.weapons_carried & #WEAP_INCENDIARY || self.weapons_carried & #WEAP_LIGHTNING || self.weapons_carried & #WEAP_AIRF || self.weapons_carried & #WEAP_ASSAULT_CANNON || self.weapons_carried & #WEAP_DAEDALUS || (self.cutf_items & #CUTF_SENTRYGUN && self.weapons_carried & #WEAP_SPANNER) || (self.weapons_carried & #WEAP_SPANNER && self.tf_items & #NIT_TESLA) || (self.weapons_carried & #WEAP_SPANNER && self.tf_items & #NIT_SECURITY_CAMERA) || (self.weapons_carried & #WEAP_SPANNER && self.tf_items & #NIT_TELEPORTER) || (self.weapons_carried & #WEAP_SPANNER && self.cutf_items & #CUTF_FIELDGEN) || (self.weapons_carried & #WEAP_SPANNER && self.cutf_items & #CUTF_SENSOR)))
		if (!(self.cutf_items & (128 | 131072) || self.weapons_carried & (4194304 | 16384 | 65536 | 32768 | 131072 | 2097152) || (self.cutf_items & 16 && self.weapons_carried & 8) || (self.weapons_carried & 8 && self.tf_items & 32768) || (self.weapons_carried & 8 && self.tf_items & 65536) || (self.weapons_carried & 8 && self.tf_items & 131072) || (self.weapons_carried & 8 && self.cutf_items & 524288) || (self.weapons_carried & 8 && self.cutf_items & 256)))
		//if (!(self.weapons_carried & #WEAP_SPANER && (self.cutf_items & (CUTF_SENTRYGUN |   )  )))
			newmis.ammo_cells = self.ammo_cells;
	}

	// If there's nothing in the backpack, remove it and return
	if (!(newmis.ammo_shells + newmis.ammo_nails + newmis.ammo_rockets + newmis.ammo_cells))
	{
		dremove(newmis);
		return;
	}

	// Remove the ammo from the player
	if (newmis.ammo_shells)
		self.ammo_shells = 0;
	if (newmis.ammo_nails)
		self.ammo_nails = 0;
	if (newmis.ammo_rockets)
		self.ammo_rockets = 0;
	if (newmis.ammo_cells)
		self.ammo_cells = 0;
	W_SetCurrentAmmo();

	sound(self, 3, "weapons/lock4.wav", 1, 1);

	// The backpack is treated as an ammobox, so people can't crash svrs
	// by making too many of them.
	if (self.team_no != 0)
	{
		increment_team_ammoboxes(self.team_no);
		if (num_team_ammoboxes(self.team_no) > (6 / number_of_teams))
			RemoveOldAmmobox(self.team_no);
	}
	else 
	{
		num_world_ammoboxes = num_world_ammoboxes + 1;
		if (num_world_ammoboxes > 6)
			RemoveOldAmmobox(0);
	}

	// Throw the backpack
	newmis.enemy = self;
	newmis.health = time;
	newmis.weapon = 0;
	newmis.movetype = 6;
	newmis.solid = 1;
	newmis.classname = "ammobox";
	newmis.team_no = self.team_no;
	makevectors (self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = v_forward*400 + v_up * 200;
	}
	else
	{
		newmis.velocity = aim(self, 10000);
		newmis.velocity = newmis.velocity * 400;
		newmis.velocity_z = 200;
	}
	newmis.avelocity = '0 300 0';
	setsize (newmis, '-16 -16 0', '16 16 56');
	setorigin (newmis, self.origin);
	newmis.nextthink = time + 30;	// remove after 30 seconds
	newmis.think = SUB_Remove;
	newmis.touch = TeamFortress_AmmoboxTouch;
	setmodel (newmis, "progs/backpack.mdl");

	// Gizmo - make sure it's not going to fall off the map, because of the new size
	newmis.owner = self;
	if ( InSolid( newmis ) ) {
		setorigin( newmis, self.origin - '0 0 24' );
	}
	newmis.owner = world;
};

//=========================================================================
// Shows any medics/engineers on your team that you need help.
// Spies see all requests.
void() TeamFortress_SaveMe =
{
	local entity te, tl;

	if (self.last_saveme_sound < time)
	{
		if (random() < 0.8)
			sound(self, 1, "speech/saveme1.wav", 1, 1); // MEDIC!
		else
			sound(self, 1, "speech/saveme2.wav", 1, 1); // Excuse me...
		self.last_saveme_sound = time + 4;
	}

	te = find(world, classname, "player");
	while (te)
	{	
		//if (self.weapons_carried & #WEAP_MEDIKIT) OfN WTF?
		  // Was ==, wtf?
		if (self != te || te.weapons_carried & 4 || te.weapons_carried & 8 || te.cutf_items & 4) //WK Custom class friendly
		{
			if (Teammate(self.team_no, te.team_no) || (te.cutf_items & 4))
			{
				// If the other teammate is visible, show them I need help
				if (visible(te))
				{
					msg_entity = te;
					tl = spawn();
					tl.origin = self.origin;
					tl.origin_z = tl.origin_z + 32;
					WriteByte (1, 23);
					WriteByte (1, 9);
					WriteEntity (1, tl);
					WriteCoord (1, tl.origin_x);
					WriteCoord (1, tl.origin_y);
					WriteCoord (1, tl.origin_z + 24);
					WriteCoord (1, self.origin_x);
					WriteCoord (1, self.origin_y);
					WriteCoord (1, self.origin_z);
					dremove(tl);
				}
			}
		}

		te = find(te, classname, "player");
	}
};


/*
	ConstructString - Gizmo - made this function to make things easier
*/

string (string s1, string s2, string s3, string s4, string s5, string s6, string s7, string s8) ConstructString =
{
	local string ls;

	ls = strcat (s1, s2);

	if (s3 != string_null)
		ls = strcat (ls, s3);
	else
		return ls;

	if (s4 != string_null)
		ls = strcat (ls, s4);
	else
		return ls;

	if (s5 != string_null)
		ls = strcat (ls, s5);
	else
		return ls;

	if (s6 != string_null)
		ls = strcat (ls, s6);
	else
		return ls;

	if (s7 != string_null)
		ls = strcat (ls, s7);
	else
		return ls;

	if (s8 != string_null)
		ls = strcat (ls, s8);
	else
		return ls;

	return ls;
};


//=========================================================================
// ID's the player in your sights, and if you're a medic or engineer,
// reports their health and armor.
void(float inAuto) TeamFortress_ID =
{
	//WK All the inAuto and spacer stuff I added
	local vector src;
	local string st, cls;
	local string spacer;
	src = self.origin + v_forward*10;
	src_z = self.absmin_z + self.size_z * 0.7;
	if (!inAuto) //WK I.e. just someone is doing it normally
		traceline (src, src + v_forward*2048, 4, self); //#TL_ANY_SOLID
	else		//WK I.e. it is an autoscan
		traceline (src, src + v_forward*1024, 0, self); //#TL_ANY_SOLID

	if (inAuto)
	{
		if (trace_ent.classname == "player" && trace_ent.job & (1 + 2048))
			return;

		// Auto ID shouldn't pertubate menus
		if (self.current_menu != 0)
		   return; 
	}

	//if (!inAuto)
		//spacer = "\n\n\n\n\n";
		spacer = "\n";
	//else
	//	spacer = "\n\n\n\n\n\n\n";

	if (trace_ent != world && trace_ent.origin != world.origin )
	{
		
		if (trace_ent.message == "corpse")
		{
			self.StatusRefreshTime = time + 1.5;
			if (trace_ent.classname == "player")
			{
				if (trace_ent.playerclass == 11)
					cls = TeamFortress_GetJobName(trace_ent.job);
				else
					cls = TeamFortress_GetClassName(trace_ent.playerclass);

				if (Teammate(self.team_no,trace_ent.team_no))
					centerprint(self, spacer, trace_ent.netname, "'s corpse!\n\nNo ",cls," deserves this..");
				else
					centerprint(self, spacer, "This enemy ",cls," looks like\n\n",trace_ent.netname,"'s corpse!");
			
				return;
			}
			else if (trace_ent.classname == "monster_corpse")
			{
				if (trace_ent.increase_team3 == 6)
				{
					if (Teammate(self.team_no,trace_ent.team_no))
						centerprint(self, spacer, "Dead army comrade");
					else
						centerprint(self, spacer, "Dead enemy army guy");
				}
				else
				{
					if (Teammate(self.team_no,trace_ent.team_no))
						centerprint(self, spacer, "This good beast was helping");
					else
						centerprint(self, spacer, "This thing isn't alive\n\nIt smells badly though");
				}

				return;
			}
			
			// Player corpse on bodyque (unsafe to get name)
			if (Teammate(self.team_no,trace_ent.team_no))
				centerprint(self, spacer,"\nFallen teammate");
			else
				centerprint(self, spacer,"\nAn enemy rotten corpse");

			return;
		}
		else 
		
		
		if (trace_ent.classname == "item_tfgoal")
		{
			if (trace_ent.netname)
			{
				self.StatusRefreshTime = time + 1.5;
				centerprint(self,trace_ent.netname);
			}

			return;
		}
		else
		
		
		if (trace_ent.classname == "rune")
		{
			self.StatusRefreshTime = time + 1.5;
			centerprint(self,trace_ent.netname);

			return;
		}
		else
		
		/*if (trace_ent.classname == "grenade" && trace_ent.netname == "land_mine")
		{
			self.StatusRefreshTime = time + 1.5;
			if (Teammate(self.team_no,trace_ent.owner.team_no))
				centerprint(self,"Friendly Mine");
			else
				centerprint(self,"Εξενω Mine");
			return;
		}*/
		if (trace_ent.classname == "player" && trace_ent.health > 0)
		{
			self.StatusRefreshTime = time + 1.5;

			if (Teammate(trace_ent.team_no,self.team_no))
			{
				if (trace_ent.playerclass == 11)
					cls = TeamFortress_GetJobName(trace_ent.job);
				else
					cls = TeamFortress_GetClassName(trace_ent.playerclass);

				if (self.weapons_carried & 4) //WK
				{
					st = ftos(trace_ent.health);
					centerprint(self, spacer, trace_ent.netname, "\n\nFriendly ", cls, "\n\n", st, " health\n");
//centerprint(self, "\n\n\n\n", trace_ent.netname, "\nFriendly ", cls, "\n", st, //" health\n");
					return;
				}
				else if (self.weapons_carried & 8) //WK
				{
					st = ftos(trace_ent.armorvalue);
					centerprint(self, spacer, trace_ent.netname, "\n\nFriendly ", cls, "\n\n", st, " armor\n");
					return;
				}
				else
					centerprint(self, spacer, trace_ent.netname, "\n\nFriendly ", cls,"\n");
				return;
			}

			if (trace_ent.is_feigning) //WK Can't id enemy spies feigning
				return;

			if (trace_ent.cutf_items & 4)
			{
				cls = TeamFortress_GetClassName(trace_ent.undercover_skin);
				// Report a false name
				if (self.team_no != 0 && (self.team_no == trace_ent.undercover_team))
				{
					if (self.weapons_carried & 4)
					{
						st = ftos(trace_ent.health);
						if (trace_ent.undercover_skin != 0)
							centerprint(self, spacer, trace_ent.undercover_name, "\n\nFriendly ", cls, "\n\n", st, " health\n");
						else
							centerprint(self, spacer, trace_ent.undercover_name, "\n\nFriendly Spy\n\n", st, " health\n");
						return;
					}
					else if (self.weapons_carried & 8)
					{
						st = ftos(trace_ent.armorvalue);
						if (trace_ent.undercover_skin != 0)
							centerprint(self, spacer, trace_ent.undercover_name, "\n\nFriendly ", cls, "\n\n", st, " armor\n");
						else
							centerprint(self, spacer, trace_ent.undercover_name, "\n\nFriendly Spy\n\n", st, " armor\n");
						return;
					}
					else
					{
						st = ftos(trace_ent.armorvalue);
						if (trace_ent.undercover_skin != 0)
							centerprint(self, spacer, trace_ent.undercover_name, "\n\nFriendly ", cls, "\n");
						else
							centerprint(self, spacer, trace_ent.undercover_name, "\n\nFriendly Spy\n");
						return;
					}
				}

				if (trace_ent.undercover_name != string_null)
				{
					if (trace_ent.undercover_skin != 0)
						centerprint(self, spacer, trace_ent.undercover_name, "\n\nΕξενω ", cls, "\n");
					else
						centerprint(self, spacer, trace_ent.undercover_name, "\n\nΕξενω Spy");
				}
				else
				{
					if (trace_ent.undercover_skin != 0)
						centerprint(self, spacer, trace_ent.netname, "\n\nΕξενω ", cls, "\n");
					else
						centerprint(self, spacer, trace_ent.netname, "\n\nΕξενω Spy");
				}
			}
			else 
			{
				if (trace_ent.playerclass == 11) {
					cls = TeamFortress_GetJobName(trace_ent.job);
					centerprint(self, spacer, trace_ent.netname, "\n\nΕξενω ", cls, "\n");
				}
				else {
					cls = TeamFortress_GetClassName(trace_ent.playerclass);
					centerprint(self, spacer, trace_ent.netname, "\n\nΕξενω ", cls, "\n");
				}
			}
		}
		else if (trace_ent.classname == "building_dispenser")
		{
			self.StatusRefreshTime = time + 1.5;
			
			if (self == trace_ent.real_owner)
				centerprint(self, spacer,"Your Dispenser\n");
			else if (!teamplay)
				centerprint(self, spacer,"Dispenser made by\n\n", trace_ent.real_owner.netname);
			else if (Teammate(trace_ent.team_no,self.team_no))
				centerprint(self, spacer,"Friendly Dispenser made by\n\n", trace_ent.real_owner.netname, "\n");
			else 
				centerprint(self, spacer,"Εξενω Dispenser made by\n\n", trace_ent.real_owner.netname, "\n");
	
		}
		else if (trace_ent.classname == "building_fieldgen")
		{
			self.StatusRefreshTime = time + 1.5;
			
			if (self == trace_ent.real_owner)
				centerprint(self, spacer,"Your Field Generator.\n");
			else if (!teamplay)
				centerprint(self, spacer,"Field Generator made by\n\n", trace_ent.real_owner.netname);
			else if (Teammate(trace_ent.team_no,self.team_no))
				centerprint(self, spacer,"Friendly Field Generator made by\n\n", trace_ent.real_owner.netname, "\n");
			else 
				centerprint(self, spacer,"Εξενω Field Generator made by\n\n", trace_ent.real_owner.netname, "\n");
	
		}

		else if (trace_ent.classname == "building_sentrygun" || trace_ent.classname == "building_sentrygun_base")
		{
			self.StatusRefreshTime = time + 1.5;
			if (self == trace_ent.real_owner)
			{
				if (self.cutf_items & 4194304)
				{
					if (trace_ent.dont_do_triggerwork == 1)
						centerprint(self, spacer,"Your Sentry Gun #1\n");
					else if (trace_ent.dont_do_triggerwork == 2)
						centerprint(self, spacer,"Your Sentry Gun #2\n");
					else
						centerprint(self, spacer,"Your Sentry Gun\n");
				}
				else
					centerprint(self, spacer,"Your Sentry Gun\n");
			}
			else if (!teamplay)
				centerprint(self, spacer,"Sentry Gun made by\n\n", trace_ent.real_owner.netname,"\n");
			else if (Teammate(trace_ent.team_no, self.team_no))
				centerprint(self, spacer,"Friendly Sentry Gun made by\n\n", trace_ent.real_owner.netname,"\n");
			else 
				centerprint(self, spacer,"Εξενω Sentry Gun made by\n\n", trace_ent.real_owner.netname,"\n");
		}	
		else if (trace_ent.classname == "building_tesla")
		{
			self.StatusRefreshTime = time + 1.5;
			if (self == trace_ent.real_owner)
			{
				if (self.tf_items & 4194304)
				{
					if (trace_ent.dont_do_triggerwork == 1)
						centerprint(self, spacer,"Your Tesla Coil #1\n");
					else if (trace_ent.dont_do_triggerwork == 2)
						centerprint(self, spacer,"Your Tesla Coil #2\n");
					else
						centerprint(self, spacer,"Your Tesla Coil\n");
				}
				else
					centerprint(self, spacer,"Your Tesla Coil\n");				
			}
			else if (!teamplay)
				centerprint(self, spacer,"Tesla Coil made by\n\n", trace_ent.real_owner.netname,"\n");
			else if (Teammate(trace_ent.team_no, self.team_no))
				centerprint(self, spacer,"Friendly Tesla made by\n\n", trace_ent.real_owner.netname,"\n");
			else 
				centerprint(self, spacer,"Εξενω Tesla made by\n\n", trace_ent.real_owner.netname,"\n");
		}
		else if (trace_ent.classname == "building_camera")
		{
			self.StatusRefreshTime = time + 1.5;
			if (self == trace_ent.real_owner)
				centerprint(self, spacer,"Your favorite Security Camera\n");
			else if (!teamplay)
				centerprint(self, spacer,"Security Camera made by\n\n", trace_ent.real_owner.netname,"\n");
			else if (Teammate(trace_ent.team_no, self.team_no))
				centerprint(self, spacer,"Friendly Security Camera made by\n\n", trace_ent.real_owner.netname,"\n");
			else 
				centerprint(self, spacer,"Εξενω Security Camera made by\n\n", trace_ent.real_owner.netname,"\n");
		}
		else if (trace_ent.classname == "building_sensor")
		{
			self.StatusRefreshTime = time + 1.5;
			if (self == trace_ent.real_owner)
				centerprint(self, spacer,"Your favorite Motion Sensor\n");
			else if (!teamplay)
				centerprint(self, spacer,"Motion Sensor made by\n\n", trace_ent.real_owner.netname,"\n");
			else if (Teammate(trace_ent.team_no, self.team_no))
				centerprint(self, spacer,"Friendly Motion Sensor made by\n\n", trace_ent.real_owner.netname,"\n");
			else 
				centerprint(self, spacer,"Εξενω Motion Sensor made by\n\n", trace_ent.real_owner.netname,"\n");
		}
		else if (trace_ent.classname == "building_teleporter")
		{
			self.StatusRefreshTime = time + 1.5;
			if (self == trace_ent.real_owner)
				centerprint(self, spacer,"One of your favorite Teleporter Pads\n"); //CH b/c you have 2
			else if (!teamplay)
				centerprint(self, spacer,"Teleporter Pad made by\n\n", trace_ent.real_owner.netname,"\n");
			else if (Teammate(trace_ent.team_no, self.team_no))
				centerprint(self, spacer,"Friendly Teleporter Pad made by\n\n", trace_ent.real_owner.netname,"\n");
			else 
				centerprint(self, spacer,"Εξενω Teleporter Pad made by\n\n", trace_ent.real_owner.netname,"\n");
		}
		else if (trace_ent.classname == "monster_demon1")
		{
			//custom_demon_name(trace_ent); //CH
			self.StatusRefreshTime = time + 1.5;
			st = ftos(trace_ent.health);
			if (self == trace_ent.real_owner)
				centerprint(self, spacer,"Your Pet Demon ",trace_ent.netname, "\n\n", st, " health");
			else if (!teamplay)
				centerprint(self, spacer,"Demon summoned by\n\n", trace_ent.real_owner.netname);
			else if (Teammate(trace_ent.real_owner.team_no, self.team_no))
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly demon summoned by\n\n", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly demon summoned by\n\n", trace_ent.real_owner.netname);
			}
			else
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω demon summoned by\n\n", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω demon summoned by\n\n", trace_ent.real_owner.netname, "\n\n", st, " health");
			}
		}
		else if (trace_ent.classname == "monster_army")
		{
			//custom_demon_name(trace_ent); //CH
			self.StatusRefreshTime = time + 1.5;
			st = ftos(trace_ent.health);
			if (self == trace_ent.real_owner)
				centerprint(self, spacer,"Your mercenary soldier ",trace_ent.netname, "\n\n", st, " health");
			else if (!teamplay)
				centerprint(self, spacer,"Soldier in the pay of\n\n", trace_ent.real_owner.netname);
			else if (Teammate(trace_ent.real_owner.team_no, self.team_no))
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly soldier owned by\n\n", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly soldier owned by\n\n", trace_ent.real_owner.netname);
			}
			else
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω soldier owned by\n\n", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω soldier owned by\n\n", trace_ent.real_owner.netname);
			}
		}
		else if (trace_ent.classname == "monster_shambler")
		{
			//custom_demon_name(trace_ent); //CH
			self.StatusRefreshTime = time + 1.5;
			st = ftos(trace_ent.health);
			if (self == trace_ent.real_owner)
				centerprint(self, spacer,"Your Pet Shambler ",trace_ent.netname, "\n\n", st, " health");
			else if (!teamplay)
				centerprint(self, spacer,"Shambler under control of\n\n", trace_ent.real_owner.netname);
			else if (Teammate(trace_ent.real_owner.team_no, self.team_no))
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly shambler summoned by\n\n", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly shambler summoned by\n\n", trace_ent.real_owner.netname);
			}
			else
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω shambler summoned by\n\n", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω shambler summoned by\n\n ", trace_ent.real_owner.netname);
			}
		}
		else if (trace_ent.classname == "monster_fish") //- OfN
		{
			//custom_demon_name(trace_ent); 
			self.StatusRefreshTime = time + 1.5;
			st = ftos(trace_ent.health);
			if (self == trace_ent.real_owner)
				centerprint(self, spacer,"Your swimming Piranha ",trace_ent.netname, "\n\n", st, " health");
			else if (!teamplay)
				centerprint(self, spacer,"Piranha under control of\n\n", trace_ent.real_owner.netname);
			else if (Teammate(trace_ent.real_owner.team_no, self.team_no))
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly Piranha summoned by\n\n", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly Piranha summoned by\n\n", trace_ent.real_owner.netname);
			}
			else
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω Piranha summoned by\n\n ", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω Piranha summoned by\n\n", trace_ent.real_owner.netname);
			}
		}
		else if (trace_ent.classname == "monster_gremlin") //- OfN
		{
			//custom_demon_name(trace_ent); 
			self.StatusRefreshTime = time + 1.5;
			st = ftos(trace_ent.health);
			if (self == trace_ent.real_owner)
				centerprint(self, spacer,"Your dirty gremlin ",trace_ent.netname, "\n\n", st, " health");
			else if (!teamplay)
				centerprint(self, spacer,"Gremlin under control of\n\n", trace_ent.real_owner.netname);
			else if (Teammate(trace_ent.real_owner.team_no, self.team_no))
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly Gremlin summoned by\n\n", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly Gremlin summoned by\n\n", trace_ent.real_owner.netname);
			}
			else
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω Gremlin summoned by\n\n ", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω Gremlin summoned by\n\n", trace_ent.real_owner.netname);
			}
		}
		else if (trace_ent.classname == "monster_wizard") //- OfN
		{
			//custom_demon_name(trace_ent); 
			self.StatusRefreshTime = time + 1.5;
			st = ftos(trace_ent.health);
			if (self == trace_ent.real_owner)
				centerprint(self, spacer,"Your flying Scrag ",trace_ent.netname, "\n\n", st, " health");
			else if (!teamplay)
				centerprint(self, spacer,"Scrag under control of\n\n", trace_ent.real_owner.netname);
			else if (Teammate(trace_ent.real_owner.team_no, self.team_no))
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly Scrag summoned by\n\n", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nfriendly Scrag summoned by\n\n", trace_ent.real_owner.netname);
			}
			else
			{
				if (self.cutf_items & 16384)
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω Scrag summoned by\n\n ", trace_ent.real_owner.netname, "\n\n", st, " health");
				else
					centerprint(self, spacer,trace_ent.netname,"\n\nεξενω Scrag summoned by\n\n", trace_ent.real_owner.netname);
			}
		}


		else if ( COOP_IsCoopMonster( trace_ent ) ) {
			local string s1;
			local string bullet, nail, exp, elec, fire, melee;
			local string strong, weak;
			local string ar;

			// Gizmo - wouldn't this be easier to do this one time before these if statements?
			self.StatusRefreshTime = time + 1.5;
			st = ftos (trace_ent.health);
			ar = ftos (trace_ent.armorvalue);

			// Gizmo - print more information
			bullet = ftos(rint(trace_ent.money * 100));
			nail = ftos(rint(trace_ent.custom_speed * 100));
			exp = ftos(rint(trace_ent.ff_count * 100));
			elec = ftos(rint(trace_ent.hover_time * 100));
			fire = ftos(rint(trace_ent.penance_time * 100));
			melee = ftos(rint(trace_ent.has_cheated * 100));
			//bullet = colstr (bullet, #COLSTR_NUMBER);
			//nail = colstr (nail, #COLSTR_NUMBER);
			//exp = colstr (exp, #COLSTR_NUMBER);
			//elec = colstr (elec, #COLSTR_NUMBER);
			//fire = colstr (fire, #COLSTR_NUMBER);
			//melee = colstr (melee, #COLSTR_NUMBER);

			s1 = string_null;
			strong = "Strong";
			weak = "Weak";
			if (trace_ent.money) {
				if (trace_ent.money < 0.95)
					s1 = ConstructString (strong, "―", bullet, "%", " against βυμμετσ\n", string_null, string_null, string_null);
			}
			if (trace_ent.custom_speed) {
				if (trace_ent.custom_speed < 0.95)
					s1 = ConstructString (s1, strong, "―", nail, "%", " against ξαιμσ\n", string_null, string_null);
			}
			if (trace_ent.ff_count) {
				if (trace_ent.ff_count < 0.95)
					s1 = ConstructString (s1, strong, "―", exp, "%", " against εψπμοσιοξσ\n", string_null, string_null);
			}
			if (trace_ent.hover_time) {
				if (trace_ent.hover_time < 0.95)
					s1 = ConstructString (s1, strong, "―", elec, "%", " against εμεγτςιγιτω\n", string_null, string_null);
			}
			if (trace_ent.penance_time) {
				if (trace_ent.penance_time < 0.95)
					s1 = ConstructString (s1, strong, "―", fire, "%", " against ζιςε\n", string_null, string_null);
			}
			if (trace_ent.has_cheated) {
				if (trace_ent.has_cheated < 0.95)
					s1 = ConstructString (s1, strong, "―", melee, "%", " against νεμεε ατταγλσ\n", string_null, string_null);
			}

			if (s1 != string_null)
				s1 = strcat (s1, "\n");

			if (trace_ent.money) {
				if (trace_ent.money > 1)
					s1 = ConstructString (s1, weak, "―", bullet, "%", " against βυμμετσ\n", string_null, string_null);
			}
			if (trace_ent.custom_speed) {
				if (trace_ent.custom_speed > 1)
					s1 = ConstructString (s1, weak, "―", nail, "%", " against ξαιμσ\n", string_null, string_null);
			}
			if (trace_ent.ff_count) {
				if (trace_ent.ff_count > 1)
					s1 = ConstructString (s1, weak, "―", exp, "%", " against εψπμοσιοξσ\n", string_null, string_null);
			}
			if (trace_ent.hover_time) {
				if (trace_ent.hover_time > 1)
					s1 = ConstructString (s1, weak, "―", elec, "%", " against εμεγτςιγιτω\n", string_null, string_null);
			}
			if (trace_ent.penance_time) {
				if (trace_ent.penance_time > 1)
					s1 = ConstructString (s1, weak, "―", fire, "%", " against ζιςε\n", string_null, string_null);
			}
			if (trace_ent.has_cheated) {
				if (trace_ent.has_cheated > 1)
					s1 = ConstructString (s1, weak, "―", melee, "%", " against νεμεε ατταγλσ\n", string_null, string_null);
			}
			//delstr (bullet);
			//delstr (nail);
			//delstr (exp);
			//delstr (elec);
			//delstr (fire);
			//delstr (melee);

			if (self.cutf_items & 16384) {
				s1 = ConstructString (ar, " armor\n\n", s1, string_null, string_null, string_null, string_null, string_null);
				if ( Teammate( trace_ent.team_no, self.team_no ) )
					centerprint( self, "\nfriendly ", trace_ent.netname, "\n\n", st, " health\n", s1 );
				else
					centerprint( self, "\nAn εξενω ", trace_ent.netname, "\n\n", st, " health\n", s1 );
			} else {
				if ( Teammate( trace_ent.team_no, self.team_no ) )
					centerprint( self, "\nfriendly ", trace_ent.netname, "\n\n", s1 );
				else
					centerprint( self, "\nAn εξενω ", trace_ent.netname, "\n\n", s1 );
			}

			// for when an observer
			// Gizmo - wtf? why not use time + ... ? using every frame is unreliable
			self.menu_count = 0;
		}

	}
};

//=========================================================================
// Reloads the current weapon
void() TeamFortress_ReloadCurrentWeapon =
{
	local float rt;
	local entity tWeapon;

	// OfN - Psionized guys can't reload
	if (self.tfstate & 1048576)
	{
		sprint(self,2,"You can't reload right now!\n");
		return;
	}

	//---------------- CLIP EXTENDER (same as below but with _EX values -------------//
	if (self.cutf_items & 262144)
	{
		if (self.current_weapon == 128)
		{
			if (self.reload_shotgun == 0)
			{
				sprint(self, 2, "Clip full.\n");
				return;
			}

			if ( self.reload_shotgun < self.ammo_shells)
			{
				Attack_Finished(0.4);

				// Calculate the reload time needed
				rt = (12 - self.reload_shotgun) / 12;
				rt = 2 - (2 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_shotgun = 0;
				if (self.ammo_shells < 12)
					self.reload_shotgun = 12 - self.ammo_shells;
			   
				sprint(self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_shotgun;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
			else
			{
				sprint(self, 2, "not enough ammo to reload\n");
			}
		}
		else if (self.current_weapon == 256)
		{
			if (self.reload_super_shotgun == 0)
			{
				sprint (self, 2, "Clip full.\n");
				return;
			}

			if ( self.reload_super_shotgun < self.ammo_shells)
			{
				Attack_Finished(0.7);

				// Calculate the reload time needed
				rt = (24 - self.reload_super_shotgun) / 24;
				rt = 3 - (3 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_super_shotgun = 0;
				if (self.ammo_shells < 24)
					self.reload_super_shotgun = 24 - self.ammo_shells;

				sprint (self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_super_shotgun;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
			else
			{
				sprint (self, 2, "not enough ammo to reload\n");
			}
		}
		else if (self.current_weapon == 4194304)
		{
			if (self.reload_laser_cannon == 0)
			{
				sprint (self, 2, "Cannon already in full charge.\n");
				return;
			}

			if ( self.reload_laser_cannon < self.ammo_cells)
			{
				Attack_Finished(2);

				// Calculate the reload time needed
				rt = (10 - self.reload_laser_cannon) / 10;
				rt = 1.5 - (1.5 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_laser_cannon = 0;
				if (self.ammo_cells < 10)
					self.reload_laser_cannon = 10 - self.ammo_cells;

				sprint (self, 2, "Charging cannon...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_laser_cannon;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
			else
			{
				sprint (self, 2, "not enough cells to recharge\n");
			}
		}
		else if (self.current_weapon == 1024)
		{
			if (self.reload_light_assault == 0)
			{
				sprint (self, 2, "Clip full.\n");
				return;
			}

			if ( self.reload_light_assault < self.ammo_nails)
			{
				Attack_Finished(2);

				// Calculate the reload time needed
				rt = (36 - self.reload_light_assault) / 36;
				rt = 3.4 - (3.4 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_light_assault = 0;
				if (self.ammo_nails < 36)
					self.reload_light_assault = 36 - self.ammo_nails;

				sprint (self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_light_assault;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
			else
			{
				sprint (self, 2, "not enough ammo to reload\n");
			}
		}
		else if (self.current_weapon == 2048)
		{
			if (self.reload_grenade_launcher == 0)
			{
				sprint (self, 2, "Clip full.\n");
				return;
			}
			
			if (self.reload_grenade_launcher < self.ammo_rockets)
			{
				Attack_Finished(0.6);

				// Calculate the reload time needed
				rt = (8 - self.reload_grenade_launcher) / 8;
				rt = 4 - (4 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_grenade_launcher = 0;
				if (self.ammo_rockets < 8)
					self.reload_grenade_launcher = 8 - self.ammo_rockets;

				sprint (self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_grenade_launcher;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
			else 
			{
				sprint (self, 2, "not enough ammo to reload\n");
			}
		}
		else if (self.current_weapon == 8192)
		{
			if (self.reload_rocket_launcher == 0)
			{
				sprint (self, 2, "Clip full.\n");
				return;
			}

			if (self.reload_rocket_launcher < self.ammo_rockets)
			{
				Attack_Finished(0.8);

				// Calculate the reload time needed
				rt = (5 - self.reload_rocket_launcher) / 5;
				rt = 5 - (5 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_rocket_launcher = 0;

				if (self.ammo_rockets < 5)
					self.reload_rocket_launcher = 5 - self.ammo_rockets;

				sprint (self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_rocket_launcher;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
		}

	

	} // CLIP EXTENDER
	else
	{
		if (self.current_weapon == 128)
		{
			if (self.reload_shotgun == 0)
			{
				sprint(self, 2, "Clip full.\n");
				return;
			}

			if ( self.reload_shotgun < self.ammo_shells)
			{
				Attack_Finished(0.4);

				// Calculate the reload time needed
				rt = (8 - self.reload_shotgun) / 8;
				rt = 2 - (2 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_shotgun = 0;
				if (self.ammo_shells < 8)
					self.reload_shotgun = 8 - self.ammo_shells;
			   
				sprint(self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_shotgun;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
			else
			{
				sprint(self, 2, "not enough ammo to reload\n");
			}
		}
		else if (self.current_weapon == 256)
		{
			if (self.reload_super_shotgun == 0)
			{
				sprint (self, 2, "Clip full.\n");
				return;
			}

			if ( self.reload_super_shotgun < self.ammo_shells)
			{
				Attack_Finished(0.7);

				// Calculate the reload time needed
				rt = (16 - self.reload_super_shotgun) / 16;
				rt = 3 - (3 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_super_shotgun = 0;
				if (self.ammo_shells < 16)
					self.reload_super_shotgun = 16 - self.ammo_shells;

				sprint (self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_super_shotgun;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
			else
			{
				sprint (self, 2, "not enough ammo to reload\n");
			}
		}
		else if (self.current_weapon == 4194304)
		{
			if (self.reload_laser_cannon == 0)
			{
				sprint (self, 2, "Cannon already in full charge.\n");
				return;
			}

			if ( self.reload_laser_cannon < self.ammo_cells)
			{
				Attack_Finished(2);

				// Calculate the reload time needed
				rt = (6 - self.reload_laser_cannon) / 6;
				rt = 1.5 - (1.5 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_laser_cannon = 0;
				if (self.ammo_cells < 6)
					self.reload_laser_cannon = 6 - self.ammo_cells;

				sprint (self, 2, "Charging cannon...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_laser_cannon;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
			else
			{
				sprint (self, 2, "not enough cells to recharge\n");
			}
		}
		else if (self.current_weapon == 1024)
		{
			if (self.reload_light_assault == 0)
			{
				sprint (self, 2, "Clip full.\n");
				return;
			}

			if ( self.reload_light_assault < self.ammo_nails)
			{
				Attack_Finished(2);

				// Calculate the reload time needed
				rt = (30 - self.reload_light_assault) / 30;
				rt = 3.2 - (3.2 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_light_assault = 0;
				if (self.ammo_nails < 30)
					self.reload_light_assault = 30 - self.ammo_nails;

				sprint (self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_light_assault;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
			else
			{
				sprint (self, 2, "not enough ammo to reload\n");
			}
		}
		else if (self.current_weapon == 2048)
		{
			if (self.reload_grenade_launcher == 0)
			{
				sprint (self, 2, "Clip full.\n");
				return;
			}
			
			if (self.reload_grenade_launcher < self.ammo_rockets)
			{
				Attack_Finished(0.6);

				// Calculate the reload time needed
				rt = (6 - self.reload_grenade_launcher) / 6;
				rt = 4 - (4 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_grenade_launcher = 0;
				if (self.ammo_rockets < 6)
					self.reload_grenade_launcher = 6 - self.ammo_rockets;

				sprint (self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_grenade_launcher;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
			else 
			{
				sprint (self, 2, "not enough ammo to reload\n");
			}
		}
		else if (self.current_weapon == 8192)
		{
			if (self.reload_rocket_launcher == 0)
			{
				sprint (self, 2, "Clip full.\n");
				return;
			}

			if (self.reload_rocket_launcher < self.ammo_rockets)
			{
				Attack_Finished(0.8);

				// Calculate the reload time needed
				rt = (4 - self.reload_rocket_launcher) / 4;
				rt = 5 - (5 * rt);

				if (self.runes_owned & 4)
					rt = rt * 0.8;

				self.reload_rocket_launcher = 0;

				if (self.ammo_rockets < 4)
					self.reload_rocket_launcher = 4 - self.ammo_rockets;

				sprint (self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn();
				tWeapon.netname = "reloadtimer"; //WK For Judoka code
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				tWeapon.nextthink = time + rt;
				tWeapon.think = W_Reload_rocket_launcher;

				self.weaponmodel = "";
				self.weaponframe = 0;
			}
		}
	} // CLIP EXTENDER (END ELSE)
};

//CH drops an item TF goal if the bits are set to allow it.
float() TeamFortress_DropItems =
{
	local entity tg;
	local float counter;

	counter = 0;
	//local string temp;

	tg = find (world, classname, "item_tfgoal");
	while (tg)
	{
		if (tg.owner == self && tg != world && tg.classname == "item_tfgoal")
		{
			if (tg.goal_activation & 4096) // Grievre fix: was goal_result
			{
				if (tg.netname)
					sprint (self, 2, "Dropping item: ", tg.netname, "\n");
				
				counter = counter + 1;

				if (counter > 1)
					tfgoalitem_RemoveFromPlayer(tg, self, 0);
				else
					tfgoalitem_RemoveFromPlayer(tg, self, 2); // last param was 0, OfN added 2, which tosses item in player dir, see tfortmap.qc
//CH it treats it as though you died.  And if bits are set, you throw it, or it gets removed etc.
			}
		}

		tg = find(tg, classname, "item_tfgoal");
	}

	return counter;
};

