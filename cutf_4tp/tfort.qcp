/*======================================================
	TFORT.QC			Custom TeamFortress v3.2	

	(c) TeamFortress Software Pty Ltd	29/2/97
	(c) William Kerney			9/16/00
	(c) Craig Hauser				19/3/00
========================================================
Class handling and other utility functions
======================================================*/
// Function Prototypes
//void() RemoveFlare;
void() GrenadeExplode;
void() spike_touch;
void(entity p) bound_other_ammo;
void(entity Goal, entity Player, entity Item) DisplayItemStatus;
void (entity targ, entity inflictor, entity attacker, float damage, float T_flags, float T_AttackType) TF_T_Damage;

// Map Function Prototypes
void(entity Item, entity AP, float method) tfgoalitem_RemoveFromPlayer;

// Help Functions
void() TeamFortress_MOTD;

// Team Functions
float(float tno) TeamFortress_TeamGetColor;
void(float tno) TeamFortress_TeamSetColor;
float() TeamFortress_TeamPutPlayerInTeam;
float(float tno) TeamFortress_TeamGetScore;
float(float tno) TeamFortress_TeamGetIllegalClasses;

//WK
void() DropToCustomClassGen; //In custom.qc
float() W_BestWeapon; //In weapons.qc
void() FragGrenadeTouch; //In custom.qc
void() FragGrenadeExplode;
void() KracGrenadeTouch;
void() KracGrenadeExplode;
void() AntiGravGrenadeExplode;
void() Autoitem_think;
void() DetonateAllGuns;

// Impulse Functions
void() TeamFortress_ChangeClass;
void() TeamFortress_DisplayLegalClasses;
void() TeamFortress_Inventory;
void( entity dest, entity g, float printLevel ) Grunty_PrintDetails;
void() TeamFortress_ShowTF;
void() TeamFortress_PrimeGrenade;
void() TeamFortress_ThrowGrenade;
void() TeamFortress_DisplayDetectionItems;

// Player Class Handling Functions
float(float pc) IsLegalClass;
//void() TeamFortress_SetAlias; //WK
void() TeamFortress_SetHealth;
void() TeamFortress_SetEquipment;
void(entity p) TeamFortress_SetSpeed;
void(entity p) TeamFortress_SetSkin;
void(entity Viewer, float pc, float rpc) TeamFortress_PrintClassName;
void() TeamFortress_RemoveTimers;
void(float Suicided) TeamFortress_SetupRespawn;
void() TeamFortress_CheckClassStats;
float(entity Retriever, float AmmoType) TeamFortress_GetMaxAmmo;
float(entity Retriever, float WeaponType) TeamFortress_CanGetWeapon;
float(entity Retriever, entity Items) TeamFortress_AddBackpackItems;
float(entity Player, float Armorclass) TeamFortress_DescribeArmor;




// AmmoBox Handling Functions
void () TeamFortress_AmmoboxTouch;
float (float tno) num_team_ammoboxes;
void(float tno) RemoveOldAmmobox;
void(float tno) increment_team_ammoboxes;
void(float tno) decrement_team_ammoboxes;

// Weapon Handling Functions
void() TeamFortress_ExplodePerson;
void() NormalGrenadeTouch;
void() NormalGrenadeExplode;
void() PlayerObserverMode;

// Utility Functions
void(string halias, float himpulse1, float himpulse2) TeamFortress_Alias;

// Cyclic Event Functions
void() TeamFortress_Regenerate;
void() TeamFortress_RegenerateCyber;
void() TeamFortress_RegenerateCells;

//CH
float(entity p) Return_Custom_Skins;

//- OfN
void() FlareGrenadeTouch;
void() FlareGrenadeExplode;
void() FlareBounce;
void(entity sld) grunty_boundammo;
void(entity player) UpdateCells;
void () BioGrenadeTouch;
void () BioGrenadeExplode;
float(entity theplayer, float grenslot) GetMaxGrens;
string(float runetype) GetRuneString;
float(entity player) StripDisallowed;
float(entity player) GiveFreeStuff;
float(entity player) RestoreOriginalItems;
void(entity player) ResetStripedAndGiven;

//=========================================================================
// IMPULSE FUNCTIONS
//=========================================================================
// Uses a class dependant special skill
void() UseSpecialSkill =
{
	self.impulse = 0;

	if (self.cutf_items & 16 || self.tf_items & 32768 || self.tf_items & 65536 || self.tf_items & 131072 || self.cutf_items & 1024 || self.cutf_items & 524288)
		self.impulse = 179;
	else if (self.cutf_items & 4)
		self.impulse = 177;
	else if (self.weapons_carried & 2048)
		self.impulse = 170;
	else if (self.tf_items & 1)
		self.impulse = 163;
	else if (self.weapons_carried & 32)
		self.impulse = 174;
	else
		self.impulse = 173;

	//WK Since most people don't know "disguise" or "build"
	// we'll allow them to toggle between the two with special.
	// This wipes out .money, so watch out for side effects.
	if (!(self.done_custom & 4) && (self.impulse == 179) && (self.cutf_items & 4))
	{
		if (self.money) self.money = 0;
		else self.money = 1;

		if (self.money)
			self.impulse = 179;
		else 
		{
			if (self.effects & (8 | 4)) //CH why not have the check here too, saves a keypress
				self.impulse = 179;
			else
				self.impulse = 177;
		}
	}
};


//=========================================================================
// Player change class function
// If self.impulse == 1, change to Civilian class
void() TeamFortress_ChangeClass =
{
	local entity spot, te;
	//local float tc;
	local string st;
	//local string scratch;
	local float	destClass;

	//WK - Handle Custom Class Restarting
	if (self.playerclass == 11 && self.done_custom & 4) {
		destClass = self.impulse - 100;
		DropToCustomClassGen(); //Comatose state

		// Gizmo - if we typed a stock class then buy the items for that class
		if ( destClass != 11 )
			BuyStockClassItems( destClass );
		return;
	}

	if (self.playerclass != 0 && !(self.playerclass == 11 && (self.done_custom & 4)))
	{

		// In Deathmatch 3, you can change class after you die
		if (deathmatch != 3 && !coop)
			return;






		// Civilian Teams can never change class
		if (TeamFortress_TeamIsCivilian(self.team_no))
		{
			sprint(self, 2, "You're a civilian. Learn to live with it.\n");
			return; 		
		}

		if (!IsLegalClass(self.impulse - 100))
		{
			sprint(self, 2, "Your team cannot play that class.\n");

			TeamFortress_DisplayLegalClasses();
			return;
		}

		self.nextpc = self.impulse - 100;
		//WK - Handle Custom Class
		if (self.nextpc == 11)
		{
			self.done_custom = self.done_custom | 1; //Generate a new custom class when we respawn
		}

		sprint(self, 2, "After dying, you will return as a ");
		st = TeamFortress_GetClassName(self.nextpc);
		//st = colstr(st,2);
		sprint(self, 2, st, "\n");
		return;
	}

	// players must join a team, if teamplay is on
	if (teamplay && self.team_no == 0) 
	{
		sprint(self, 2, "You must join a team first. \n");
		return;
	}

	// Only change if you've got any lives left
	if ( self.lives == 0 )
	{
		sprint(self, 2, "You have no lives left.\n");

		return;
	}

	if (!IsLegalClass(self.impulse - 100) && (self.impulse != 1))
	{
		sprint(self, 2, "You cannot play that playerclass on this map. \n");

		TeamFortress_DisplayLegalClasses();
		return;
	}

	// Spy may be disabled
	if ((spy_off == 1) && ((self.impulse - 100) == 8))
	{
		sprint(self, 2, "The spy class has been disabled on the server by the administrator.\n");
		return;
	}

	if (self.impulse != 1)
		self.playerclass = self.impulse - 100;
	else
		self.playerclass = 12;

	self.nextpc = 0;

	// Turn off #PC_UNDEFINED's nomove and invincibility
	self.takedamage = 2;
	//WK Prevent bad movetype errors, or something
	if (self.classname != "player") {
		RPrint("BUG BUG BUG BUG BUG BUG BUG BUG BUG\n");
		RPrint("Non-player was in tfort.qc::changeclass()!\n");
		return;
	}
	
	self.movetype = 3;
	self.flags = 8 | 512;
	self.waterlevel = 0;
	self.air_finished = time + 12;

	// give them a model, and a new spawn point
	self.solid = 3;
	// pausetime is set by teleporters to keep the player from moving a while
	self.pausetime = 0;
	
	spot = SelectSpawnPoint ();














	self.origin = spot.origin + '0 0 1';
	self.angles = spot.angles;
	self.fixangle = 1;		// turn this way immediately

	setmodel (self, string_null);
	modelindex_null = self.modelindex;

	setmodel (self, "progs/eyes.mdl");
	modelindex_eyes = self.modelindex;

	setmodel (self, "progs/player.mdl");
	modelindex_player = self.modelindex;

	setsize (self, '-16 -16 -24', '16 16 32');	

	self.view_ofs = '0 0 22';
	player_stand1 ();
	if (deathmatch || coop)
	{
		makevectors(self.angles);
		spawn_tfog (self.origin + v_forward*20);
	}

	// Display chosen class
	if ( self.playerclass == 10 )
	{
		sprint(self, 2, "Random Playerclass.\n");

		self.tfstate = (self.tfstate | 8);
		self.playerclass = 1 + floor(random() * (10 - 1));
	}

	// If this is a TeamSpawnpoint, check to see if it
	// gives out a GoalItem, or displays a message
	if (spot.classname == "info_player_teamspawn")
	{
		if (spot.items != 0)
		{
			te = Finditem(spot.items);
			if (te)
				tfgoalitem_GiveToPlayer(te, self, self);

			if (!(spot.goal_activation & 1))
				spot.items = 0;
		}

		if (spot.message)
		{
			CenterPrint(self, spot.message);

			if (!(spot.goal_activation & 2))
				spot.message = string_null;
		}

		// TeamSpawn points can remove themselves after being spawned on
		if (spot.goal_effects == 1)
		{
			spot.classname = "deadpoint";
			spot.team_str_home = string_null;
			spot.nextthink = time + 1;
			spot.think = SUB_Remove;
		}
	}

	//WK - Handle Custom Class
	if (self.playerclass == 11) {
		DropToCustomClassGen(); //Comatose state 
	}

	ResetMenu();
	TeamFortress_PrintClassName(self,self.playerclass, (self.tfstate & 8));



	TeamFortress_SetEquipment();
	TeamFortress_SetHealth();
	TeamFortress_SetSpeed(self);
	TeamFortress_SetSkin(self);
	//WK Give them invincibility if they are a normal class or bought it
	if (self.playerclass >= 1 && self.playerclass <= 10) {
		self.items = self.items + 1048576;
		self.invincible_time = 1;

		if ( !deathmatch )
			self.invincible_finished = time + 2;
		else

		self.invincible_finished = time + 5;
	}

	// Gizmo - enable telefragging when chosing a stock class
	spawn_tdeath (self.origin, self);
};

//=========================================================================
// Display a list of all the legal classes for this map
void() TeamFortress_DisplayLegalClasses =
{
	local float gotone, ill;

	sprint(self, 2, "Legal Classes for your team are:\n");
	gotone = 0;

	ill = TeamFortress_TeamGetIllegalClasses(self.team_no);

	if (!(illegalclasses & 1) && !(ill & 1))
	{
		if (gotone)
			sprint(self, 2, ", ");
		gotone = 1;
		sprint(self, 2, "Scout");
	}
	if (!(illegalclasses & 2) && !(ill & 2))
	{
		if (gotone)
			sprint(self, 2, ", ");
		gotone = 1;
		sprint(self, 2, "Sniper");
	}
	if (!(illegalclasses & 4) && !(ill & 4))
	{
		if (gotone)
			sprint(self, 2, ", ");
		gotone = 1;
		sprint(self, 2, "Soldier");
	}
	if (!(illegalclasses & 8) && !(ill & 8))
	{
		if (gotone)
			sprint(self, 2, ", ");
		gotone = 1;
		sprint(self, 2, "Demolitions Man");
	}
	if (!(illegalclasses & 16) && !(ill & 16))
	{
		if (gotone)
			sprint(self, 2, ", ");
		gotone = 1;
		sprint(self, 2, "Combat Medic");
	}
	if (!(illegalclasses & 32) && !(ill & 32))
	{
		if (gotone)
			sprint(self, 2, ", ");
		gotone = 1;
		sprint(self, 2, "Heavy Weapons Guy");
	}
	if (!(illegalclasses & 64) && !(ill & 64))
	{
		if (gotone)
			sprint(self, 2, ", ");
		gotone = 1;
		sprint(self, 2, "Pyro");
	}
	if (!(illegalclasses & 256) && !(ill & 256))
	{
		if (gotone)
			sprint(self, 2, ", ");
		gotone = 1;
		sprint(self, 2, "Spy");
	}
	if (!(illegalclasses & 512) && !(ill & 512))
	{
		if (gotone)
			sprint(self, 2, ", ");
		gotone = 1;
		sprint(self, 2, "Engineer");
	}
	if (!(illegalclasses & 128) && !(ill & 128))
	{
		if (gotone)
			sprint(self, 2, ", ");
		gotone = 1;
		sprint(self, 2, "RandomPC");
	}

	sprint(self, 2, "\n");
};

//=========================================================================
// Displays the player's inventory

void( entity printDest, entity thething ) PrintOwnedMonsterInfo;

void() TeamFortress_Inventory =
{
	local entity tg;
	local string ac;
	local float col;
	local float special; //CH used to determine if a \n is needed for a line
	special = 0;

	// Display Team
	col = TeamFortress_TeamGetColor(self.team_no);

	sprint(self, 2, "You're in team ");
	ac = ftos(self.team_no);
	sprint(self, 2, ac);
	sprint(self, 2, ", color ");
	ac = ftos(col);
	sprint(self, 2, ac);
	sprint(self, 2, ".\n");

	// Display Lives, if applicable
	if (self.lives != -1)
	{
		ac = ftos(self.lives);

		sprint(self, 2, "You've got ");
		sprint(self, 2, ac);
		if (self.lives == 1)
			sprint(self, 2, " life.\n");
		else 
			sprint(self, 2, " lives.\n");

	}

	// Display Number of Grenades of each type
	//WK Fix BUG grenades
	if (self.tp_grenades_1 == 0)
		self.no_grenades_1 = 0;
	if (self.tp_grenades_2 == 0)
		self.no_grenades_2 = 0;

	if (self.no_grenades_1 > 0)
	{
		sprint(self, 2, "Gren.Type 1: ");
		if (self.tp_grenades_1 == 1)
			sprint(self, 2, "Normal(");
		else if (self.tp_grenades_1 == 2)
			sprint(self, 2, "Concussion(");
		else if (self.tp_grenades_1 == 12)
			sprint(self, 2, "AntiGrav(");
		else if (self.tp_grenades_1 == 3)
			sprint(self, 2, "Nail(");
		else if (self.tp_grenades_1 == 4)
			sprint(self, 2, "Mirv(");
		else if (self.tp_grenades_1 == 5)
			sprint(self, 2, "Napalm(");
		else if (self.tp_grenades_1 == 6)
			sprint(self, 2, "Flare(");
		else if (self.tp_grenades_1 == 7)
			sprint(self, 2, "Hallucinogenic(");
		else if (self.tp_grenades_1 == 8)
			sprint(self, 2, "EMP(");
		



		else if (self.tp_grenades_1 == 9)
			sprint(self, 2, "Psionic(");
		
		else if (self.tp_grenades_1 == 10)
			sprint(self, 2, "Frag(");
		else if (self.tp_grenades_1 == 11)
			sprint(self, 2, "Krac(");
		else if (self.tp_grenades_1 == 14)
			sprint(self, 2, "Caltrop(");
		else if (self.tp_grenades_1 == 13)
			sprint(self, 2, "Biological(");
		else 
			sprint(self, 2, "BUG(");

		ac = ftos(self.no_grenades_1);
		sprint(self, 2, ac);
		sprint(self, 2, ")\n");
	}
	if (self.no_grenades_2 > 0)
	{
		sprint(self, 2, "Gren.Type 2: ");
		if (self.tp_grenades_2 == 1)
			sprint(self, 2, "Normal(");
		else if (self.tp_grenades_2 == 2)
			sprint(self, 2, "Concussion(");
		else if (self.tp_grenades_2 == 3)
			sprint(self, 2, "Nail(");
		else if (self.tp_grenades_2 == 12)
			sprint(self, 2, "AntiGrav(");
		else if (self.tp_grenades_2 == 14)
			sprint(self, 2, "Caltrop(");
		else if (self.tp_grenades_2 == 4)
			sprint(self, 2, "Mirv(");
		else if (self.tp_grenades_2 == 13)
			sprint(self, 2, "Biological(");
		else if (self.tp_grenades_2 == 5)
			sprint(self, 2, "Napalm(");
		else if (self.tp_grenades_2 == 6)
			sprint(self, 2, "Flare(");
		else if (self.tp_grenades_2 == 7)
			sprint(self, 2, "Hallucinogenic(");
		else if (self.tp_grenades_2 == 8)
			sprint(self, 2, "EMP(");
		



		else if (self.tp_grenades_2 == 9)
			sprint(self, 2, "Psionic(");
		
		else if (self.tp_grenades_2 == 10)
			sprint(self, 2, "Frag(");
		else if (self.tp_grenades_2 == 11)
			sprint(self, 2, "Krac(");
		else 
			sprint(self, 2, "BUG(");

		ac = ftos(self.no_grenades_2);
		sprint(self, 2, ac);
		sprint(self, 2, ")\n");
	}


	// Scanner
	if (self.tf_items & 1)
	{
		sprint(self, 2, "Scanner. ");
		special = special + 1; //CH determines \n
	}
	if (self.cutf_items & 32)
	{
		sprint(self, 2, "Jammer. ");
		special = special + 1; //CH determines \n
	}

	if (self.cutf_items & 128 && !(self.weapons_carried & 4))
	{
		sprint(self, 2, "CyberAug (");
		ac = ftos(self.ammo_medikit);
		sprint(self, 2, ac);
		sprint(self, 2, "). ");
		special = special + 1; //CH determines \n
	}
	else if (self.cutf_items & 128 && self.weapons_carried & 4)
		sprint(self, 2, "CyberAug/");
	// Medikit and ammo
	if (self.weapons_carried & 4)
	{
		sprint(self, 2, "Medikit (");
		ac = ftos(self.ammo_medikit);
		sprint(self, 2, ac);
		sprint(self, 2, "). ");
		special = special + 1; //CH determines \n
	}

	//if (self.cutf_items & #CUTF_INTERFACE)  //- OfN -
	//	sprint(self, #PRINT_HIGH, "Cyber Interface. ");


	// Detpack
	if (self.cutf_items & 1)
	{
		if (self.ammo_detpack > 0)
		{
			ac = ftos(self.ammo_detpack);

			sprint(self, 2, ac);
			sprint(self, 2, " Detpack");
			if (self.ammo_detpack > 1)
				sprint(self, 2, "s");
			sprint(self, 2, ". ");
			special = special + 1; //CH determines \n
		}
	}
	if (self.cutf_items & 512)
	{
		if (self.ammo_c4det > 0)
		{
			ac = ftos(self.ammo_c4det);

			sprint(self, 2, ac);
			sprint(self, 2, " Tossable Detpack");
			if (self.ammo_c4det > 1)
				sprint(self, 2, "s");
			sprint(self, 2, ". ");
			special = special + 1; //CH determines \n
		}
	}

	// GoalItems
	tg = find (world, classname, "item_tfgoal");
	while (tg)
	{
		if (tg.owner == self)
		{
			sprint(self, 2, tg.netname);
			sprint(self, 2, ". ");
			special = special + 1; //CH determines \n
		}

		tg = find(tg, classname, "item_tfgoal");
	}

	// Armor
	if (self.armorvalue > 0)
	{
		special = special + TeamFortress_DescribeArmor(self, self.armorclass);
	}
if (special > 0)
	sprint(self, 2, "\n");

if (!invis_only)
{
	// Spy gets told what skin and color he/she is wearing
	if ((self.cutf_items & 4) && invis_only == 0)
	{
		sprint (self, 2, "Skin : ");
		if (self.undercover_skin != 0)
			TeamFortress_PrintClassName(self,self.undercover_skin,0);
		else
			TeamFortress_PrintClassName(self,self.skin,0);

		sprint (self, 2, "Colors : Team ");
		if (self.undercover_team != 0)
			ac = ftos(self.undercover_team);
		else
			ac = ftos(self.team_no);
		sprint (self, 2, ac);
		sprint(self, 2, "\n");
	}
}

	// OfN - Display the health of any summons/army guys
	if (self.job & 4 || self.job & 128) 
	{
		if ( self.demon_one )
			PrintOwnedMonsterInfo( self, self.demon_one );

		if ( self.demon_two )
			PrintOwnedMonsterInfo( self, self.demon_two );

		if ( self.demon_three )
			PrintOwnedMonsterInfo( self, self.demon_three );
	}

	if (self.has_sentry)
	{
		tg = find(world, classname, "building_sentrygun");
		while (tg)
		{
			if (tg.real_owner == self)
			{
				ac = ftos(ceil(tg.health));
				
				if (!tg.dont_do_triggerwork || !(self.cutf_items & 4194304))
					sprint (self, 2, "σεξτςω: ");
				else
				{
					if (tg.dont_do_triggerwork == 1)
						sprint (self, 2, "σεξτςω £: ");
					else if (tg.dont_do_triggerwork == 2)
						sprint (self, 2, "σεξτςω £: ");
					else
						sprint (self, 2, "σεξτςω: ");
				}
				sprint (self, 2, ac);
				sprint (self, 2, "―");
				ac = ftos(ceil(tg.max_health));
				sprint (self, 2, ac);
				sprint (self, 2, " θπ\n");

			}
			tg = find(tg, classname, "building_sentrygun");
		}
	}
	if (self.has_tesla)
	{
		tg = find(world, classname, "building_tesla");
		while (tg)
		{
			if (tg.real_owner == self)
			{
				ac = ftos(ceil(tg.health));

				
				if (!tg.dont_do_triggerwork || !(self.tf_items & 4194304))
					sprint (self, 2, "τεσμα: ");
				else
				{
					if (tg.dont_do_triggerwork == 1)
						sprint (self, 2, "τεσμα £: ");
					else if (tg.dont_do_triggerwork == 2)
						sprint (self, 2, "τεσμα £: ");
					else
						sprint (self, 2, "τεσμα: ");
				}

				//sprint (self, #PRINT_HIGH, "τεσμα: ");
				sprint (self, 2, ac);
				sprint (self, 2, "―");
				ac = ftos(ceil(tg.max_health));
				sprint (self, 2, ac);
				sprint (self, 2, " θπ\n");

			}
			tg = find(tg, classname, "building_tesla");
		}
	}
	if (self.has_dispenser)
	{
		tg = find(world, classname, "building_dispenser");
		while (tg)
		{
			if (tg.real_owner == self)
			{
				ac = ftos(ceil(tg.health));
				sprint (self, 2, "δισπεξσες: ");
				sprint (self, 2, ac);
				sprint (self, 2, "―");
				ac = ftos(ceil(tg.max_health));
				sprint (self, 2, ac);
				sprint (self, 2, " θπ\n");

			}
			tg = find(tg, classname, "building_dispenser");
		}
	}
	if (self.has_sensor)
	{
		tg = find(world, classname, "building_sensor");
		while (tg)
		{
			if (tg.real_owner == self)
			{
				ac = ftos(ceil(tg.health));
				sprint (self, 2, "σεξσος: ");
				sprint (self, 2, ac);
				sprint (self, 2, "―");
				ac = ftos(ceil(tg.max_health));
				sprint (self, 2, ac);
				sprint (self, 2, " θπ\n");

			}
			tg = find(tg, classname, "building_sensor");
		}
	}
	if (self.has_camera)
	{
		tg = find(world, classname, "building_camera");
		while (tg)
		{
			if (tg.real_owner == self)
			{
				ac = ftos(ceil(tg.health));
				sprint (self, 2, "γανεςα: ");
				sprint (self, 2, ac);
				sprint (self, 2, "―");
				ac = ftos(ceil(tg.max_health));
				sprint (self, 2, ac);
				sprint (self, 2, " θπ\n");

			}
			tg = find(tg, classname, "building_camera");
		}
	}
	if (self.has_teleporter > 0)
	{
		tg = find(world, classname, "building_teleporter");
		while (tg)
		{
			if (tg.real_owner == self)
			{
				ac = ftos(ceil(tg.health));
				sprint (self, 2, "τεμεποςτες: ");
				sprint (self, 2, ac);
				sprint (self, 2, "―");
				ac = ftos(ceil(tg.max_health));
				sprint (self, 2, ac);
				sprint (self, 2, "θπ ");

				ac = ftos(ceil(tg.ammo_cells));
				sprint (self, 2, ac);
				sprint (self, 2, "―");
				ac = ftos(ceil(tg.maxammo_cells));
				sprint (self, 2, ac);
				sprint (self, 2, "γεμμσ");
				
				if (!(tg.tf_items & 2))
				{
					sprint (self, 2, "\n");					 
				}
				else
				{
					sprint (self, 2, "¨T©\n");
				}

			}
			tg = find(tg, classname, "building_teleporter");
		}
	}
	if (self.has_fieldgen > 0)
	{
		tg = find(world, classname, "building_fieldgen");
		while (tg)
		{
			if (tg.real_owner == self)
			{
				ac = ftos(ceil(tg.health));
				sprint (self, 2, "Ζιεμδ Ηεξεςατος: ");
				sprint (self, 2, ac);
				sprint (self, 2, "―");
				ac = ftos(ceil(tg.max_health));
				sprint (self, 2, ac);
				sprint (self, 2, "θπ ");

				ac = ftos(ceil(tg.ammo_cells));
				sprint (self, 2, ac);
				sprint (self, 2, "―");
				ac = ftos(ceil(tg.maxammo_cells));
				sprint (self, 2, ac);
				sprint (self, 2, "γεμμσ\n");

			}
			tg = find(tg, classname, "building_fieldgen");
		}
	}

	/*if (self.job & #JOB_WARLOCK && self.job & #JOB_DEMON_OUT)
	{
		sprint (self, #PRINT_HIGH, "You have a ");
		ac=GetMonsterName(self.demon_two);
		sprint (self, #PRINT_HIGH, ac);
		sprint (self, #PRINT_HIGH, " summoned: ");

		tg = find(world, classname, "monster_demon1");
		while (tg)
		{
			if (tg.real_owner == self)
			{
				ac = ftos(ceil(tg.health));
				//sprint (self, #PRINT_HIGH, " (");
				sprint (self, #PRINT_HIGH, ac);
				sprint (self, #PRINT_HIGH, " HP ");
			}
			tg = find(tg, classname, "monster_demon1");
		}
		
		tg = find(world, classname, "monster_army");
		while (tg)
		{
			if (tg.real_owner == self)
			{
				ac = ftos(ceil(tg.health));
				sprint (self, #PRINT_HIGH, " (");
				sprint (self, #PRINT_HIGH, ac);
				sprint (self, #PRINT_HIGH, ") ");
			}
			tg = find(tg, classname, "monster_army");
		}

		tg = find(world, classname, "monster_shambler");
		while (tg)
		{
			if (tg.real_owner == self)
			{
				ac = ftos(ceil(tg.health));
				//sprint (self, #PRINT_HIGH, " (");
				sprint (self, #PRINT_HIGH, ac);
				sprint (self, #PRINT_HIGH, " HP ");
			}
			tg = find(tg, classname, "monster_shambler");
		}

		tg = find(world, classname, "monster_wizard");
		while (tg)
		{
			if (tg.real_owner == self)
			{
				ac = ftos(ceil(tg.health));
				//sprint (self, #PRINT_HIGH, " (");
				sprint (self, #PRINT_HIGH, ac);
				ac = ftos(ceil(tg.max_health));
				sprint (self, #PRINT_HIGH, "―");
				sprint (self, #PRINT_HIGH, ac);
				sprint (self, #PRINT_HIGH, " HP ");
			}
			tg = find(tg, classname, "monster_wizard");
		}

		//sprint (self, #PRINT_HIGH, ac);
		sprint (self, #PRINT_HIGH, "\n");
	}*/
	
	/*if (self.job & #JOB_WARLOCK) // they can see that on warlock menu
	{
		ac = ftos (self.demon_blood);
		sprint (self, #PRINT_HIGH, "Knife kills: ", ac, "\n");	// knife kills
	}*/    

	//CH if you have boots, state percent of fuel
	if (self.tf_items & 16384)
	{
		if (self.hover_time <= 0)
			ac = "0";
		else
			ac = ftos(floor(100 * (self.hover_time / 5)));
		sprint (self, 2, "Boot Charge: ");
		sprint (self, 2, ac);
		sprint (self, 2, "%  ");
	}
	//CH if you have a job.  tell when can work
	if (self.job & 2047)
	{
		if ((self.job_finished - time) <= 0)
			sprint (self,2, "Skill Time: ");
		else
		{
			ac = ftos(ceil(self.job_finished - time));
		sprint (self,2, "Skill Time:");
		sprint (self, 2, ac);
		if (ceil(self.job_finished - time) == 1)
			sprint (self, 2, " second");
		else
			sprint (self, 2, " seconds");
		}
	}

	if (self.aura) //- OfN - If we have an aura it should tell
	{
		if (self.crusader_inspirator != world && self.crusader_inspirator.is_connected && self.crusader_inspirator.classname == "player")
		{
			sprint(self,2,"\n");
			sprint(self,2,self.crusader_inspirator.netname);
			sprint(self,2," grants you the AURA of ");
		}
		else
			sprint(self,2,"\nYou enjoy the AURA of ");
		
		if (self.aura == 1)
			sprint(self,2,"ποχες.");
		else if (self.aura == 2)
			sprint(self,2,"ςεσισταξγε.");
		else if (self.aura == 3)
			sprint(self,2,"θαστε.");
		else if (self.aura == 4)
			sprint(self,2,"ιξφισιβιμιτω.");
		else if (self.aura == 5)
			sprint(self,2,"ςεηεξεςατιοξ.");
		else if (self.aura == 6)
			sprint(self,2,"σπεεδ.");
	}

	if (self.runes_owned) // OfN - List all the runes we own
	{
		if (self.runes_owned & 1)
		{
			ac = GetRuneString(1);
			sprint(self,2,"\nYou have the ",ac,".");
		}
		if (self.runes_owned & 2)
		{
			ac = GetRuneString(2);
			sprint(self,2,"\nYou have the ",ac,".");
		}
		if (self.runes_owned & 4)
		{
			ac = GetRuneString(4);
			sprint(self,2,"\nYou have the ",ac,".");
		}
		if (self.runes_owned & 8)
		{
			ac = GetRuneString(8);
			sprint(self,2,"\nYou have the ",ac,".");
		}
	}
	// Attackers Go Red mode -PZ
	//if (agr) AGR_invPrint();

	sprint (self, 2, "\n");
};

//=========================================================================
// Displays the state of the ToggleFlags
void() TeamFortress_ShowTF =
{
	local string st;

	// Class Persistence between lvls On/Off
	if (toggleflags & 1)
		sprint (self, 2, "Class Persistence On.\n");
	else
		sprint (self, 2, "Class Persistence Off.\n");

	// Cheat Checking On/Off
	if (toggleflags & 2)
		sprint (self, 2, "Cheat Checking On.\n");
	else
		sprint (self, 2, "Cheat Checking Off.\n");

	// AutoTeam On/Off
	if (toggleflags & 64)
		sprint (self, 2, "AutoTeam On.\n");
	else
		sprint (self, 2, "AutoTeam Off.\n");

	// RespawnDelay
	if (toggleflags & 4)
		st = ftos(respawn_delay_time);
	else
		st = "No";
	sprint (self, 2, st);
	if (st != "No")
		sprint (self, 2, " second");
	sprint (self, 2, " Respawn Delay.\n");

	// TeamFrags On/Off
	if (toggleflags & 128)
		sprint (self, 2, "TeamFrags On.\n");
	else
		sprint (self, 2, "TeamFrags Off.\n");

	// Grapple hook
	if (allow_hook)
		sprint (self, 2, "Grapple On.\n");
	else
		sprint (self, 2, "Grapple Off.\n");

};

void() TeamFortress_GrenadePrimed;

//=========================================================================
// Primes a grenade of the type corresponding to the player's impulse
void() TeamFortress_PrimeGrenade =
{
	local float gtype;
	local string gs, ptime;
	local entity tGrenade;

	/*if (self.job & #JOB_THIEF && self.job & #JOB_FULL_HIDE) {
		sprint(self,#PRINT_HIGH,"You can't throw grens while invisible\n");
		return;
	}*/

	// If you've already primed a grenade, return
	if ((self.tfstate & 1) || (self.tfstate & 1024))
	{
		return;
	}

	// WK 2/8/7 You can only prime one grenade per 3 seconds
	if (time < self.last_grenade_primed + 1)
	{
		//sprint(self,#PRINT_HIGH,"You can only prime one grenade every 3 seconds\n");
		return;
	}

	// OfN - Psionized guys can't prime grenades
	if (self.tfstate & 1048576)
	{
		sprint(self,2,"You hardly have control over your hands!\n");
		return;
	}

	if (self.impulse == 150)
	{

		//WK Stop frag spammming // enabled again
		if (self.tp_grenades_1 == 10 && self.no_grenades_1 > 0) {
			if ((self.team_no == 1 && team1nextspam >= time) ||
				  (self.team_no == 2 && team2nextspam >= time) ||
					  (self.team_no == 3 && team3nextspam >= time) ||
				(self.team_no == 4 && team4nextspam >= time)) {
				sprint(self,2,"Your team already has a spam grenade in the world.\n");
				return;
			}
			if (self.team_no == 1) team1nextspam = time + 7;
			if (self.team_no == 2) team2nextspam = time + 7;
			if (self.team_no == 3) team3nextspam = time + 7;
			if (self.team_no == 4) team4nextspam = time + 7;
			
		} // OfN Removed spam control // enabled again
		gtype = self.tp_grenades_1;
		if (gtype == 2)
			gs = "Concussion grenade";
		else if (gtype == 12)
			gs = "AntiGrav grenade";
		else if (gtype == 13)
			gs = "Biological grenade";
		else if (gtype == 14)
			gs = "Caltrop grenade";
		else if (gtype == 3)
			gs = "Nail grenade";
		else if (gtype == 4)
			gs = "Mirv grenade";
		else if (gtype == 5)
			gs = "Napalm grenade";
		else if (gtype == 6)
			gs = "Flare";
		else if (gtype == 7)
			gs = "Gas grenade";
		else if (gtype == 8)
			gs = "EMP grenade";
		



		else if (gtype == 9)
			gs = "Psionic grenade";
		
		else if (gtype == 10)
			gs = "Fragmentation grenade";
		else if (gtype == 11)
			gs = "Krac grenade";
		else
			gs = "Grenade";

		if (self.no_grenades_1 >= 1)
		{
			ptime = ftos( 3 );

			sprint(self, 2, gs);
			sprint(self, 2, " primed, ");
			sprint(self, 2, ptime);
			sprint(self, 2, " seconds...\n");

			/*if ((self.tp_grenades_1 == #GR_TYPE_NAIL || self.tp_grenades_1 == #GR_TYPE_FRAG) && self.no_grenades_1 > 2)
				self.no_grenades_1 = 2;*/

			if (self.no_grenades_1 > GetMaxGrens(self,1))
				self.no_grenades_1 = GetMaxGrens(self,1);


			self.no_grenades_1 = self.no_grenades_1 - 1;
			self.last_grenade_primed = time; //WK 2/26/7 Gren prime bugfix

			// OfN 
			//sound(self, #CHAN_MISC, "weapons/pinpull.wav", 1, #ATTN_IDLE);
		}
		else
		{
			sprint(self, 2, "No ");
			sprint(self, 2, gs);
			sprint(self, 2, "s left.\n");
			return;
		}
	}
	//if (self.impulse == #TF_GRENADE_2)
	else
	{
		if (self.tp_grenades_2 == 10  && self.no_grenades_2 > 0) {
			if ((self.team_no == 1 && team1nextspam >= time) ||
				(self.team_no == 2 && team2nextspam >= time) ||
					  (self.team_no == 3 && team3nextspam >= time) ||
				(self.team_no == 4 && team4nextspam >= time)) {
				sprint(self,2,"Your team already has a spam grenade in the world.\n");
				return;
			}
			if (self.team_no == 1) team1nextspam = time + 7 + 1;
			if (self.team_no == 2) team2nextspam = time + 7 + 1;
			if (self.team_no == 3) team3nextspam = time + 7 + 1;
			if (self.team_no == 4) team4nextspam = time + 7 + 1;
			
		} // OfN Removed spam control
		gtype = self.tp_grenades_2;
		if (gtype == 2)
			gs = "Concussion grenade";
		else if (gtype == 12)
			gs = "AntiGrav grenade";
		else if (gtype == 13)
			gs = "Biological grenade";
		else if (gtype == 14)
			gs = "Caltrop grenade";
		else if (gtype == 3)
			gs = "Nail grenade";
		else if (gtype == 4)
			gs = "Mirv grenade";
		else if (gtype == 5)
			gs = "Napalm grenade";
		else if (gtype == 6)
			gs = "Flare";
		else if (gtype == 7)
			gs = "Gas grenade";
		else if (gtype == 8)
			gs = "EMP grenade";
		



		else if (gtype == 9)
			gs = "Psionic grenade";
		
		else if (gtype == 10)
			gs = "Fragmentation grenade";
		else if (gtype == 11)
			gs = "Krac grenade";
		else
			gs = "Grenade";

		
/*		  if (gtype == #GR_TYPE_CONCUSSION)
			gs = "Concussion grenade";
		else if (gtype == #GR_TYPE_NAIL)
			gs = "Nail grenade";
		else if (gtype == #GR_TYPE_MIRV)
			gs = "Mirv grenade";
		else if (gtype == #GR_TYPE_NAPALM)
			gs = "Napalm grenade";
		else if (gtype == #GR_TYPE_FLARE)
			gs = "Flare";
		else if (gtype == #GR_TYPE_GAS)
			gs = "Gas grenade";
		else if (gtype == #GR_TYPE_EMP)
			gs = "EMP grenade";
		else if (gtype == #GR_TYPE_FLASH)
			gs = "Flash grenade";
		else if (gtype == #GR_TYPE_FRAG)
			gs = "Fragmentation grenade";
		else if (gtype == #GR_TYPE_BIO)
			gs = "BioInfection grenade";
		else if (gtype == #GR_TYPE_CALTROP)
			gs = "Caltrop grenade";

		else if (gtype == #GR_TYPE_KRAC)
			gs = "Krac grenade";
		else
			gs = "Grenade";*/

		if (self.no_grenades_2 >= 1)
		{
			ptime = ftos( 3 );

			sprint(self, 2, gs);
			sprint(self, 2, " primed, ");
			sprint(self, 2, ptime);
			sprint(self, 2, " seconds...\n");

			//WK Limit Nail grenades to 2 - ofn and frag
			
			if (self.no_grenades_2 > GetMaxGrens(self,2))
				self.no_grenades_2 = GetMaxGrens(self,2);

			/*if ((self.tp_grenades_2 == #GR_TYPE_NAIL || self.tp_grenades_2 == #GR_TYPE_FRAG) && self.no_grenades_2 > 2)
				self.no_grenades_2 = 2;*/

			self.no_grenades_2 = self.no_grenades_2 - 1;
			self.last_grenade_primed = time; //WK 2/26/7 Gren Prime Bugfix

			//sound(self, #CHAN_MISC, "weapons/pinpull.wav", 1, #ATTN_IDLE);
		}
		else
		{
			sprint(self, 2, "No ");
			sprint(self, 2, gs);
			sprint(self, 2, "s left.\n");
			return;
		}
	}

	self.tfstate = (self.tfstate | 1);
	tGrenade = spawn();
	tGrenade.owner = self;
	tGrenade.weapon = gtype;
	tGrenade.classname = "grenade_timer"; // OfN - New classname to fix gren in spawn
	tGrenade.nextthink = time + 0.8;
	tGrenade.heat = time + 3 + 0.8;
	tGrenade.think = TeamFortress_GrenadePrimed;
	if (gtype == 14)
		tGrenade.heat = tGrenade.heat - 3;
};

void() TeamFortress_GrenadePrimed =
{
	local entity user;
	local entity oldself;

	user = self.owner;

	if (!(user.tfstate & 1024) && !user.deadflag)
	{
		self.nextthink = time + 0.1;

		if (!self.think)
			dremove(self);
		
		if (time > self.heat)
			TeamFortress_ExplodePerson();

		return;
	}

	if (!(user.tfstate & 1))
	{
		RPrint("GrenadePrimed logic error\n"); // OFN: FIXME: This happens!
		dremove(self); // OfN <-- fixed ancient bug?
		return; // OfN <-- fixed ancient bug?
	}

	user.tfstate = user.tfstate - (user.tfstate & 1);
	user.tfstate = user.tfstate - (user.tfstate & 1024);

	// ofn
	if (self.weapon == 6)
		sound (user, 1, "weapons/flmfire2.wav", 1, 1);
	else
		sound (user, 1, "weapons/grenade.wav", 1, 1);
		//sound (user, #CHAN_WEAPON, "weapons/throw.wav", 1, #ATTN_NORM);

	KickPlayer(-1, user);
	newmis = spawn ();
	newmis.owner = user;
	newmis.movetype = 10;
	newmis.solid = 2;
	newmis.classname = "grenade";
	
	// set grenade speed
	makevectors (user.v_angle);

	if (user.deadflag)
	{
		// if user is dead, throw grenade directly up
		newmis.velocity = '0 0 200';
	}
	else
	{
		if (user.v_angle_x)
		{
			newmis.velocity = v_forward*600 + v_up * 200 + crandom()*v_right*10 + crandom()*v_up*10;

			if (user.tfstate & 1048576) // Weak toss when psionized
				newmis.velocity = newmis.velocity * 0.3;
		}
		else
		{
			newmis.velocity = aim(user, 10000);
			newmis.velocity = newmis.velocity * 600;
			newmis.velocity_z = 200;

			if (user.tfstate & 1048576) // Weak toss when psionized
				newmis.velocity = newmis.velocity * 0.3;
		}
	}

	newmis.angles = vectoangles(newmis.velocity);

	// set the grenade's thinktime to when the PRIMETIME runs out
	newmis.think = SUB_Null;
	newmis.nextthink = self.heat;

	// set the think and touches to the appropriate grenade type
	if (self.weapon == 1)
	{
		newmis.touch = NormalGrenadeTouch;
		newmis.think = NormalGrenadeExplode;
		newmis.skin = 0;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");

	}
	else if (self.weapon == 2)
	{
		newmis.touch = ConcussionGrenadeTouch;
		newmis.think = ConcussionGrenadeExplode;
		newmis.skin = 1;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	else if (self.weapon == 13)
	{
		newmis.touch = BioGrenadeTouch;
		newmis.think = BioGrenadeExplode;
		newmis.skin = 0;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	else if (self.weapon == 14)
	{
		newmis.touch = SUB_Null;
		newmis.think = CaltropGrenadeExplode;
		newmis.skin = 0;
		newmis.avelocity = '0 0 0';
		newmis.velocity = '0 0 0';
		setmodel (newmis, string_null);
	}
	else if (self.weapon == 12)
	{
		newmis.touch = ConcussionGrenadeTouch;
		newmis.think = AntiGravGrenadeExplode;
		newmis.skin = 1;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	else if (self.weapon == 3)
	{
		newmis.touch = NailGrenadeTouch;
		newmis.think = NailGrenadeExplode;
		newmis.skin = 1;
		newmis.avelocity = '0 300 0';
		setmodel (newmis, "progs/biggren.mdl");
	}
	else if (self.weapon == 4)
	{
		newmis.touch = MirvGrenadeTouch;
		newmis.think = MirvGrenadeExplode;
		newmis.skin = 0;
		newmis.avelocity = '0 300 0';
		setmodel (newmis, "progs/biggren.mdl");
	}
	else if (self.weapon == 5)
	{
		newmis.touch = NapalmGrenadeTouch;
		newmis.think = NapalmGrenadeExplode;
		newmis.skin = 2;
		newmis.avelocity = '100 300 100';
		setmodel (newmis, "progs/biggren.mdl");
	}
//CH flares no longer used
	else if (self.weapon == 6)
	{
		newmis.movetype = 5;
		newmis.touch = FlareGrenadeTouch;
		newmis.think = FlareGrenadeExplode;
		//newmis.skin  = 0;//TF_FLARE_OFF;
		newmis.avelocity = '0 0 0';
		

		makevectors (user.v_angle);
		newmis.velocity = v_forward;
		//newmis.velocity = aim(user, 10000);
		newmis.velocity = newmis.velocity * 2000;
		
//		  newmis.velocity = newmis.velocity * 4;
		//newmis.velocity_z = 0;
		setmodel (newmis, "progs/flarefly.mdl");
		newmis.skin=0;
		newmis.has_holo=0; //flag turned on when explodes
	}
	else if (self.weapon == 7)
	{
		newmis.touch = GasGrenadeTouch;
		newmis.think = GasGrenadeExplode;
		newmis.skin = 3;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/grenade2.mdl");
	}
	else if (self.weapon == 8)
	{
		newmis.touch = EMPGrenadeTouch;
		newmis.think = EMPGrenadeExplode;
		newmis.skin = 4;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/grenade2.mdl");
	}
	









	else if (self.weapon == 9)
	{
		newmis.touch = PsionicGrenadeTouch;
		newmis.think = PsionicGrenadeExplode;
		newmis.skin = 2;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	
//WK New Grenades
	else if (self.weapon == 10)
	{
		newmis.touch = FragGrenadeTouch;
		newmis.think = FragGrenadeExplode;
		newmis.skin = 0; //WK Green Skin
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	else if (self.weapon == 11)
	{
		newmis.touch = KracGrenadeTouch;
		newmis.think = KracGrenadeExplode;
		newmis.skin = 1; //WK Conc skin
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}

	setsize (newmis, '0 0 0', '0 0 0'); 	
	setorigin (newmis, user.origin);

	// OfN
	if (self.weapon == 6)
	{
	  setorigin (newmis, user.origin + '0 0 16');
	}

	oldself = self;
	self = self.owner;






	self = oldself;

	// Remove primed grenade object 
	dremove(self);
};

//=========================================================================
// Throws a currently primed grenade
void() TeamFortress_ThrowGrenade =
{
	// If no grenade is primed, return
	if (!(self.tfstate & 1))
		return;

	//WK Tossing a gren reveals yourself (so people don't spam)
	//if (self.job & #JOB_THIEF && (self.job & #JOB_ACTIVE || self.job & #JOB_FULL_HIDE))
	if (self.job & 1 && self.job & 4096)
		RevealThief(self,0);

	self.tfstate = self.tfstate | 1024;
};

//=========================================================================
// PLAYER CLASS HANDLING FUNCTIONS
//=========================================================================
// Return #TRUE is this class is allowed on this map
float(float pc) IsLegalClass =
{
	local float bit;

	// Spy may be turned off
	if (spy_off == 1 && pc == 8)
		return 0;

	if (pc == 1)
		bit = 1;
	else if (pc == 2)
		bit = 2;
	else if (pc == 3)
		bit = 4;
	else if (pc == 4)
		bit = 8;
	else if (pc == 5)
		bit = 16;
	else if (pc == 6)
		bit = 32;
	else if (pc == 7)
		bit = 64;
	else if (pc == 8)
		bit = 256;
	else if (pc == 9)
		bit = 512;
//	else if (pc == #PC_RANDOM)
	else
//WK	else if (pc == #PC_RANDOM || pc == #PC_CUSTOM) //WK Disabling randompc disables //WK customclass
		bit = 128;

	if ((illegalclasses & bit) || (TeamFortress_TeamGetIllegalClasses(self.team_no) & bit))
		return 0;

	return 1;
};

//=========================================================================
// Alter the player's Movement based on class
void(entity p) TeamFortress_SetSpeed =
{
	//local string sp;
	local float tf;
	local entity te;

	//stuffcmd(p,"cl_movespeedkey 1\n");

	makeImmune(self,time + 1.1); //WK Don't boot someone decelerating

	// - OfN -//
	//-------------------------------------------------------------------------//
	// STOP THAT SILLY DAMN BUGS, SPY SLIDING ETC.. !!!!!!!!!!!!!!!!!!!!!!!!! -//
	if (p.is_feigning || p.is_haxxxoring || p.is_detpacking || p.is_building)
		p.tfstate = p.tfstate | 65536;
	//-------------------------------------------------------------------------//

	// Check for any reason why they can't move at all
	if (p.tfstate & 65536)
	{
		if (1 == 1)
		{
			stuffcmd(p,"m_forward 0\n");
			stuffcmd(p,"m_side 0\n");
		}

		p.velocity = '0 0 0';
		stuffcmd(p,"cl_backspeed 0\n");
		stuffcmd(p,"cl_forwardspeed 0\n");
		stuffcmd(p,"cl_sidespeed 0\n");
		p.maxspeed = 0;
		return;
	}
	else
	{
		if (1 == 1)
		{
			stuffcmd(p,"m_forward 1\n");
			stuffcmd(p,"m_side 0.8\n");
		}
	}

	// First, get their max class speed
	// WK We don't use this block much any more
	if ( p.playerclass == 1 )
	{p.maxspeed = 420;}
	else if ( p.playerclass == 2 )
	{p.maxspeed = 320;}
	else if ( p.playerclass == 3 )
	{p.maxspeed = 250;}
	else if ( p.playerclass == 4 )
	{p.maxspeed = 290;}
	else if ( p.playerclass == 5 )
	{p.maxspeed = 340;}
	else if ( p.playerclass == 6 )
	{p.maxspeed = 250;}
	else if ( p.playerclass == 7 )
	{p.maxspeed = 290;}
	else if ( p.playerclass == 12 )
	{p.maxspeed = 290;}
	else if ( p.playerclass == 8 )
	{p.maxspeed = 320;}
	else if ( p.playerclass == 9 )
	{p.maxspeed = 290;}
	else if ( p.playerclass == 0 )
	{p.maxspeed = 320;return;}

	else if ( p.playerclass == 11 )
	{
		p.maxspeed = p.custom_speed;
		if (p.done_custom & 4) //We are building a class
			p.maxspeed = 0;
	}

	//1st if we have scuba gear and are underwater, increase speed
	if ((p.tf_items & 512) && (p.flags & 16))
		p.maxspeed = p.maxspeed + 200;
	//Fins slow us down out of water
	if ((p.tf_items & 512) && !(p.flags & 16))
		p.maxspeed = p.maxspeed - 10; //WK 1-7-7 20

	// 2nd, see if any GoalItems are slowing them down
	tf = 0;
	te = find (world, classname, "item_tfgoal");
	while ((te != world) && (tf == 0))
	{
		if (te.owner == p)
		{
			if (te.goal_activation & 2)
			{
				tf = 1;
				p.maxspeed = p.maxspeed / 2;
			}
		}
		te = find(te, classname, "item_tfgoal");
	}

	// 3rd, See if they're tranquilised
	if (p.tfstate & 32768)
	{
		//WK p.maxspeed = (p.maxspeed / 3) * 2;
		if (p.maxspeed > 170)
			p.maxspeed = 170;
	}
	
	if (p.tfstate & 524288)
		p.maxspeed = p.maxspeed / 3;

	// 4th, check for leg wounds
	if (p.leg_damage)
	{
		if (p.leg_damage > 9)
			p.leg_damage = 9;

		// reduce speed by 10% per leg wound
		p.maxspeed = (p.maxspeed * ((10 - p.leg_damage) / 10));
	}

	// 5th, if they're a sniper, and they're aiming, their speed must be 60 or less
	//WK Changed to allow aiming at half base leg speed, it's more fun that way.
	if (p.tfstate & 2048)
	{
		// Gizmo - changed this slower to balance out higher sniper damage
		if (p.maxspeed > 60)
			p.maxspeed = p.maxspeed / 3;
	}

	// WK 6th, See if they're partially hidden
	if (p.job & 1)
	{
		if (p.job & 2048)
			p.maxspeed = (p.maxspeed * 3) / 4;
		else if (p.job & 4096)
			if (p.maxspeed > 130)
				p.maxspeed = 130;
	}

	//WK 7th, Check to see if they are sprinting or recovering
	//Note that tired is both ACTIVE and TIRED
	if (p.job & 2) {
		if (p.job & 8192)
			p.maxspeed = 2 * p.maxspeed / 3;
		else if (p.job & 2048)
			p.maxspeed = p.maxspeed + 200;
	}

	// OfN - Speed aura miltiplies our final speed
	if (p.aura == 6)
		p.maxspeed = p.maxspeed * 1.3;

	// OfN - Speed rune muliplies our speed too
	if (p.runes_owned & 4)
		p.maxspeed = p.maxspeed * 1.35;

	// OfN - Finally, the psionic stuff
	if (p.tfstate & 1048576)
		p.maxspeed = p.maxspeed * 0.5;

	// WK See if they are ass cannoning WK 2/26/7 -- Slowed down 
	// WK 2/8/7 We allow ass cannons to move now, slowly
	if (p.button0 && p.current_weapon == 32768)
	{
		p.maxspeed = p.maxspeed / 3;
	}



	
		stuffcmd(p,"cl_backspeed 1000\n");
		stuffcmd(p,"cl_forwardspeed 1000\n");
		stuffcmd(p,"cl_sidespeed 1000\n");
	












};

//=========================================================================
// Set the max_health of a player based on his/her class
void() TeamFortress_SetHealth = 
{
	if ( self.playerclass == 1 )
		self.max_health = 75;
	else if ( self.playerclass == 2 )
		self.max_health = 90;
	else if ( self.playerclass == 3 )
		self.max_health = 100;
	else if ( self.playerclass == 4 )
		self.max_health = 90;
	else if ( self.playerclass == 5 )
		self.max_health = 90;
	else if ( self.playerclass == 6 )
		self.max_health = 100;
	else if ( self.playerclass == 7 )
		self.max_health = 100;
	else if ( self.playerclass == 12 )
		self.max_health = 90;
	else if ( self.playerclass == 8 )
		self.max_health = 90;
	else if ( self.playerclass == 9 )
		self.max_health = 100;
	else if ( self.playerclass == 0 )
	{
		self.max_health = 1; 
		self.takedamage = 0; // Prevent damage to #PC_UNDEFINED players
	}

	self.health = self.max_health;
};
//==================================================
//CH returns value for skin.  used here and tfortmap.qc
float(entity p) Return_Custom_Skins =
{
	if (p.weapons_carried & 32)
		return 2;
	else if (p.weapons_carried & 32768)
		return 6;
	else if (p.weapons_carried & 8192)
		return 3;
	else if (p.weapons_carried & 4096)
		return 7;
	else if (p.weapons_carried & 2048)
		return 4;
	else if (p.weapons_carried & 4)
		return 5;
	else if (p.weapons_carried & 8)
		return 9;
	else if (p.weapons_carried & 512)
		return 1;
	else if (p.job & 32)
		return 4;
	else if (p.custom_speed > 320 || p.job & 2)
		return 1;
	else if (p.cutf_items & 4)
		return 8;
	else if (p.cutf_items & 16 || p.tf_items & 32768)
		return 9;
	else
		return 3;
};
//=========================================================================
// Set the skin of a player based on his/her class, if Classkin is on
void(entity p) TeamFortress_SetSkin = 
{
	//local string st;

	makeImmune(self,time + 4);
	//self.immune_to_check = time + 4;


	if ((p.cutf_items & 4) && p.undercover_skin != 0)
		p.skin = p.undercover_skin;
	else
		p.skin = p.playerclass;


	if (p.skin != 0)
	{
		stuffcmd(p, "skin ");

	//WK Figure out what Mr.Custom Should look like
		if (p.playerclass == 11 && p.undercover_skin == 0)
		{
			p.skin = Return_Custom_Skins(p); //CH
		}

		if ( p.team_no == 4)
		{
			if ( p.skin == 1 )
				stuffcmd(p, "tf_scout\n");
			else if ( p.skin == 2 )
				stuffcmd(p, "tf_snipe\n");
			else if ( p.skin == 3 )
				stuffcmd(p, "tf_sold\n");
			else if ( p.skin == 4 )
				stuffcmd(p, "tf_demo\n");
			else if ( p.skin == 5 )
				stuffcmd(p, "tf_medic\n");
			else if ( p.skin == 6 )
				stuffcmd(p, "tf_hwguy\n");
			else if ( p.skin == 7 )
				stuffcmd(p, "tf_pyro\n");
			else if ( p.skin == 8 )
				stuffcmd(p, "tf_spy\n");
			else if ( p.skin == 9 )
				stuffcmd(p, "tf_eng\n");
		}
		else if ( p.team_no == 3)
		{
			if ( p.skin == 1 )
				stuffcmd(p, "tf_scout\n");
			else if ( p.skin == 2 )
				stuffcmd(p, "tf_snipe\n");
			else if ( p.skin == 3 )
				stuffcmd(p, "tf_sold\n");
			else if ( p.skin == 4 )
				stuffcmd(p, "tf_demo\n");
			else if ( p.skin == 5 )
				stuffcmd(p, "tf_medic\n");
			else if ( p.skin == 6 )
				stuffcmd(p, "tf_hwguy\n");
			else if ( p.skin == 7 )
				stuffcmd(p, "tf_pyro\n");
			else if ( p.skin == 8 )
				stuffcmd(p, "tf_spy\n");
			else if ( p.skin == 9 )
				stuffcmd(p, "tf_eng\n");
		}
		else if ( p.team_no == 2)
		{
			if ( p.skin == 1 )
				stuffcmd(p, "tf_scout\n");
			else if ( p.skin == 2 )
				stuffcmd(p, "tf_snipe\n");
			else if ( p.skin == 3 )
				stuffcmd(p, "tf_sold\n");
			else if ( p.skin == 4 )
				stuffcmd(p, "tf_demo\n");
			else if ( p.skin == 5 )
				stuffcmd(p, "tf_medic\n");
			else if ( p.skin == 6 )
				stuffcmd(p, "tf_hwguy\n");
			else if ( p.skin == 7 )
				stuffcmd(p, "tf_pyro\n");
			else if ( p.skin == 8 )
				stuffcmd(p, "tf_spy\n");
			else if ( p.skin == 9 )
				stuffcmd(p, "tf_eng\n");
		}
		else // if ( p.team_no == 1)
		{
			if ( p.skin == 1 )
				stuffcmd(p, "tf_scout\n");
			else if ( p.skin == 2 )
				stuffcmd(p, "tf_snipe\n");
			else if ( p.skin == 3 )
				stuffcmd(p, "tf_sold\n");
			else if ( p.skin == 4 )
				stuffcmd(p, "tf_demo\n");
			else if ( p.skin == 5 )
				stuffcmd(p, "tf_medic\n");
			else if ( p.skin == 6 )
				stuffcmd(p, "tf_hwguy\n");
			else if ( p.skin == 7 )
				stuffcmd(p, "tf_pyro\n");
			else if ( p.skin == 8 )
				stuffcmd(p, "tf_spy\n");
			else if ( p.skin == 9 )
				stuffcmd(p, "tf_eng\n");
		}

		if ( p.skin == 12 )
			stuffcmd(p, "base\n"); // Need a civilian skin
	}
	else
	{
		stuffcmd(p, "skin base\n"); //WK Need a custom skin, or fake it
	}

};

//=========================================================================
// Set the details of a player based on his/her class
void() TeamFortress_SetEquipment =
{
	local entity te;
	local entity automan;
	local string st;
	local float kept_items;

	if (self.classname != "player")
		return;


	if ( !deathmatch )
		kept_items = 0;
	else
		kept_items = self.tf_items & (131072 | 262144);



	
	if (self.playerclass != 11) { //WK -----v
		self.items = 0;
		self.current_weapon = 0;
		self.weapons_carried = 0;

		self.armorclass = 0;

		self.ammo_medikit = 0;
		self.maxammo_medikit = 0;
		self.ammo_detpack = 0;
		self.ammo_c4det = 0;
		self.maxammo_detpack = 0;
		self.items_allowed = 0;
		self.armor_allowed = 0;
		self.gravity = 1;
		self.maxarmor = 0;
		self.weaponmode = 0;
		self.tf_items = 0;
		self.tf_items_flags = 0;
		self.cutf_items = 0;
		self.done_custom = 0;

		//Clear job without losing track of demons, etc.
		self.job = self.job - (self.job & (2047|65536|131072));
	}
 //WK ------^
		
	self.hover_time = 0;
	if (self.tf_items & 16384)
		self.hover_time = 5; //10 secs of hovering or so
	self.respawn_time = 0;
	self.heat = 0;
	self.tfstate = self.tfstate - (self.tfstate & 2);
	if (self.tf_items & 512) //WK We're a scuba commando!
	{
		self.items = self.items | 2097152;
		self.rad_time = 1;
		self.tfstate = self.tfstate | 256;
		self.radsuit_finished = time + 666;
	}
	else
	{
		self.tfstate = self.tfstate - (self.tfstate & 256);
		self.items = 0;
		self.rad_time = 0;
		self.radsuit_finished = 0;
	}
	self.undercover_skin = 0;
	if (self.undercover_team != 0)
	{
		makeImmune(self,time + 4);
		//self.immune_to_check = time + 4;

		self.undercover_team = 0;
		// Set their color 
		stuffcmd(self, "color ");
		st = ftos(TeamFortress_TeamGetColor(self.team_no) - 1);
		 //- OfN - Nice colors
		if (nicecolors==1) st =TeamGetNiceColor(self.team_no);

		stuffcmd(self, st);
		stuffcmd(self, "\n");
	}

	self.is_building = 0;
	self.is_toffingadet = 0;
	self.is_haxxxoring = 0;
	self.is_detpacking = 0;
	self.is_undercover = 0;
	self.is_feigning = 0;
	self.is_unabletospy = 0;
	self.is_malfunctioning = 0;
	self.is_abouttodie = 0; // reset preventing automartyr flag
	
	self.martyr_enemy = self; // reset martyr enemy
	self.stored_deathmsg = 0; // reset stored death message - OfN UNUSED?

	self.impulse = 0;

	if (self.team_no == 0)
		self.lives = -1;

	self.items = self.items | kept_items;

	// Start the Cheat-Checking Cyclic Event if CheatChecking Toggleflag is on
	if (!stof(infokey(world,"nospeed")) && (toggleflags&2))
	{
		te = spawn(); //Cyto
		te.nextthink = time + 2;
		te.think = TeamFortress_CheckForSpeed;
		te.owner = self;
		te.classname = "timer";
	}

	//WK -- Remove flags for job state
	self.job = self.job - (self.job & 2048);
	self.job = self.job - (self.job & 4096);
	self.job = self.job - (self.job & 8192);
	//self.job = self.job - (self.job & #JOB_MARTYR_ENEMY);
	self.job_finished = time;

	if ( self.playerclass == 11 ) //WK - Reset the custom class
	{
		/*self.no_grenades_1 = GetMaxGrens(self,1);
		self.no_grenades_2 = GetMaxGrens(self,2);*/ //done at the end of this func


		if ( self.tf_items & 256 || !deathmatch ) {
			self.ammo_rockets = self.maxammo_rockets / 2;
			self.ammo_nails = (3 * self.maxammo_nails) / 4;
			self.ammo_shells = (3 * self.maxammo_shells) / 4;
			self.ammo_cells = (2 * self.maxammo_cells) / 3; 
		} else {
			self.ammo_rockets = self.maxammo_rockets / 4;
			self.ammo_nails = self.maxammo_nails / 2;
			self.ammo_shells = self.maxammo_shells / 2;
			self.ammo_cells = self.maxammo_cells / 2;
		}














		self.ammo_detpack = self.maxammo_detpack;
		self.ammo_c4det = self.maxammo_detpack;
		self.ammo_medikit = self.maxammo_medikit;
		if (self.ammo_medikit > 0 && self.weapons_carried & 4) {
			te = spawn();
			te.nextthink = time + 3;
			te.think = TeamFortress_Regenerate;
			te.owner = self;
			te.classname = "timer";
		}
		if (self.cutf_items & 128)
		{
			te = spawn();
			te.nextthink = time + 3;
			te.think = TeamFortress_RegenerateCyber;
			te.owner = self;
			te.classname = "timer";
		}

		// SB only need to activate this with skill
		/*if (self.job & #JOB_THIEF)
		{
			te = spawn();
			te.nextthink = time + #PC_SPY_CELL_REGEN_TIME;
			te.think = TeamFortress_RegenerateCells;
			te.owner = self;
			te.classname = "timer";
		} */


		// Gizmo - changed this for coop
		// TODO: make free instead of this hack
		if ( deathmatch ) {
			if (self.cutf_items & 64)
				self.armorvalue = self.maxarmor;
			else
				self.armorvalue = self.maxarmor / 2;
		} else
			self.armorvalue = self.maxarmor;






		self.armortype = self.armor_allowed; //Start with red if red's allowed
		self.armorclass = 0; //Default to no special armor type
		if (self.tf_items & 4)
			self.armorclass = self.armorclass | 1;
		if (self.tf_items & 8)
			self.armorclass = self.armorclass | 2;
		if (self.tf_items & 16)
			self.armorclass = self.armorclass | 4;
		if (self.tf_items & 32)
			self.armorclass = self.armorclass | 8;
		if (self.tf_items & 64) //Buying flamer gives this
			self.armorclass = self.armorclass | 16;

		//Support for the "Auto" class itemry
		if (self.tf_items & 8192 || self.weapons_carried & 4 || self.tf_items & 1024
			|| self.cutf_moreitems & 4) {
			automan = spawn ();
			automan.classname = "timer";
			automan.nextthink = time + 2;
			automan.think = Autoitem_think;
			automan.owner = self;
			automan.enemy = self;
			automan.oldenemy = self;	// Gizmo - this is so the crosshair will change color initially
		}

		self.current_weapon = W_BestWeapon ();
		//#ifdef CUSTOM_PC_ITEMS_PLAYING
		UpdateWeaponItems();
		//#endif
	}
	else if ( self.playerclass == 1 )
	{
		self.weapons_carried = self.weapons_carried | 16 | 128 | 512 | 2097152;
		self.ammo_rockets = 0;
		self.ammo_nails = 100;
		self.ammo_shells = 25;
		self.ammo_cells = 50;
		self.maxammo_rockets = 25;
		self.maxammo_nails = 100;
		self.maxammo_shells = 50;
		self.maxammo_cells = 100;

		self.no_grenades_1 = 4;
		self.no_grenades_2 = 4;
		self.tp_grenades_1 = 14;
		self.tp_grenades_2 = 2;
		self.tf_items = 65536 | 1 | 8192 | 16384 | 524288;
		self.cutf_items = 131072 | 1048576;
		self.job = self.job | 1;

		// the scanner defaults to enemy scanning ON, friendly scanning OFF
		// and movement scanner only OFF
		self.tf_items_flags = self.tf_items_flags | 1;

		self.armorclass = self.armorclass | 0;
		self.armortype = 0.3;
		self.armorvalue = 25;
		self.armor_allowed = 0.3;
		self.maxarmor = 50;
		self.current_weapon = 512;

		self.items_allowed = 16 | 128 | 512 | 2097152;
		//kill_my_demons();

		// set the weapon icons on the status bar
		self.items = self.items | 1 | 4;
	}
	else if ( self.playerclass == 2 )
	{
		self.weapons_carried = self.weapons_carried | 32 | 64 | 16 | 512;
		self.ammo_rockets = 0;
		self.ammo_nails = 50;
		self.ammo_shells = 60;
		self.ammo_cells = 0;
		self.maxammo_rockets = 25;
		self.maxammo_nails = 100;
		self.maxammo_shells = 75;
		self.maxammo_cells = 150;
	
		self.no_grenades_1 = 4;
		self.no_grenades_2 = 6;
		self.tp_grenades_1 = 1;
		self.tp_grenades_2 = 6;
		self.tf_items = 65536;
		self.job = self.job | 64;

		self.armorclass = self.armorclass | 1;
		self.armortype = 0.3;
		self.armorvalue = 50;
		self.armor_allowed = 0.3;
		self.maxarmor = 50;
		self.current_weapon = 32;

		self.items_allowed = 32 | 64 | 16 | 512;
		self.cutf_items = 0; // OFN -OTR

		// set the weapon icons on the status bar
		self.items = self.items | 1 | 2 | 4;
		//kill_my_demons();
	}
	else if ( self.playerclass == 3 )
	{
		self.weapons_carried = self.weapons_carried | 16 | 128 | 256 | 8192;
		self.ammo_rockets = 20;
		self.ammo_nails = 0;
		self.ammo_shells = 50;
		self.ammo_cells = 0;
		self.maxammo_rockets = 40;
		self.maxammo_nails = 100;
		self.maxammo_shells = 100;
		self.maxammo_cells = 50;
	
		self.no_grenades_1 = 4;
		self.no_grenades_2 = 2;
		self.tp_grenades_1 = 1;
		self.tp_grenades_2 = 3;
		self.tf_items = 0;
		self.job = self.job | 128;

		self.armorclass = self.armorclass | 0;
		self.armortype = 0.8;
		self.armorvalue = 100;
		self.armor_allowed = 0.8;
		self.maxarmor = 200;
		self.current_weapon = 8192;

		self.items_allowed = 16 | 128 | 256 | 8192;

		// set the weapon icons on the status bar
		self.items = self.items | 1 | 2 | 32;
		//kill_my_demons();
	}
	else if ( self.playerclass == 4 )
	{
		self.weapons_carried = self.weapons_carried | 16 | 128 | 2048;
		self.ammo_rockets = 20;
		self.ammo_nails = 0;
		self.ammo_shells = 30;
		self.ammo_cells = 0;
		self.maxammo_rockets = 50;
		self.maxammo_nails = 50;
		self.maxammo_shells = 75;
		self.maxammo_cells = 50;
	
		self.no_grenades_1 = 4;
		self.no_grenades_2 = 3;
		self.tp_grenades_1 = 1;
		self.tp_grenades_2 = 4;
		self.tf_items = 0;
		self.job = self.job | 32;
		self.cutf_items = 1 | 512;

		// Detpacks
		self.ammo_detpack = 1;
		self.maxammo_detpack = 1;

		self.armorclass = self.armorclass | 0;
		self.armortype = 0.6;
		self.armorvalue = 50;
		self.armor_allowed = 0.6;
		self.maxarmor = 120;
		self.current_weapon = 2048;
		//kill_my_demons();

		self.ammo_c4det = 1; // - OfN

		self.items_allowed = 16 | 128 | 2048;

		// set the weapon icons on the status bar
		self.items = self.items | 1 | 16;
	}
	else if ( self.playerclass == 5 )
	{
		self.weapons_carried = self.weapons_carried | 4 | 128 | 256 | 1024;
		self.ammo_rockets = 0;
		self.ammo_nails = 50;
		self.ammo_shells = 50;
		self.ammo_cells = 0;
		self.maxammo_rockets = 25;
		self.maxammo_nails = 150;
		self.maxammo_shells = 75;
		self.maxammo_cells = 50;
	
		self.no_grenades_1 = 3;
		self.no_grenades_2 = 2;
		self.tp_grenades_1 = 1;
		self.tp_grenades_2 = 13;
		self.tf_items = 0;
		self.job = self.job | 1024;

		self.armorclass = self.armorclass | 0;
		self.armortype = 0.3;
		self.armorvalue = 50;
		self.armor_allowed = 0.6;
		self.maxarmor = 100;
		self.current_weapon = 1024;

		self.ammo_medikit = 50;
		self.maxammo_medikit = 100;

		// Start the Regeneration Cyclic Event
		te = spawn();
		te.nextthink = time + 3;
		te.think = TeamFortress_Regenerate;
		te.owner = self;
		te.classname = "timer";

		self.items_allowed = 4 | 128 | 256 | 1024;

		// set the weapon icons on the status bar
		self.items = self.items | 1 | 2 | 8;
		//kill_my_demons();
	}
	else if ( self.playerclass == 6 )
	{
		self.weapons_carried = self.weapons_carried | 32768 | 16 | 128 | 256;
		self.ammo_rockets = 0;
		self.ammo_nails = 0;
		self.ammo_shells = 200;
		self.ammo_cells = 24;
		self.maxammo_rockets = 25;
		self.maxammo_nails = 200;
		self.maxammo_shells = 200;
		self.maxammo_cells = 50;
	
		self.no_grenades_1 = 4;
		self.no_grenades_2 = 2;
		self.tp_grenades_1 = 1;
		self.tp_grenades_2 = 4;
		self.tf_items = 0;
		self.job = self.job | 2;

		self.armorclass = self.armorclass | 0;
		self.armortype = 0.8;
		self.armorvalue = 300;
		self.armor_allowed = 0.8;
		self.maxarmor = 300;
		self.current_weapon = 256;
		self.cutf_items = 8;

		self.items_allowed = 32768 | 16 | 128 | 256;

		// set the weapon icons on the status bar
		self.items = self.items | 1 | 2 | 32;
		//kill_my_demons();
	}
	else if ( self.playerclass == 7 )
	{
		self.weapons_carried = self.weapons_carried | 16384 | 4096 | 16 | 128;
		self.ammo_rockets = 24;
		self.ammo_nails = 0;
		self.ammo_shells = 20;
		self.ammo_cells = 120;
		self.maxammo_rockets = 60;
		self.maxammo_nails = 50;
		self.maxammo_shells = 40;
		self.maxammo_cells = 200;
	
		self.no_grenades_1 = 4;
		self.no_grenades_2 = 4;
		self.tp_grenades_1 = 1;
		self.tp_grenades_2 = 5;
		self.tf_items = 16384 | 524288;
		self.job = self.job | 1;

		self.armorclass = self.armorclass | 16;
		self.armortype = 0.6;
		self.armorvalue = 50;
		self.armor_allowed = 0.6;
		self.maxarmor = 150;
		self.current_weapon = 4096;
		self.items_allowed = 16384 | 4096 | 16 | 128;
		//kill_my_demons();

		// set the weapon icons on the status bar
		self.items = self.items | 1 | 16 | 32;
	}
	else if ( self.playerclass == 12 )
	{
		self.weapons_carried = self.weapons_carried | 16 | 256 | 128;
		self.ammo_rockets = 0;
		self.ammo_nails = 0;
		self.ammo_shells = 30;
		self.ammo_cells = 0;
		self.maxammo_rockets = 0;
		self.maxammo_nails = 0;
		self.maxammo_shells = 50;
		self.maxammo_cells = 0;
	
		self.no_grenades_1 = 2;
		self.no_grenades_2 = 0;
		self.tp_grenades_1 = 1;
		self.tp_grenades_2 = 0;
		self.tf_items = 0;
		self.job = self.job | 1;

		self.armorclass = self.armorclass | 0;
		self.armortype = 0.3;
		self.armorvalue = 75;
		self.armor_allowed = 0.3;
		self.maxarmor = 75;
		self.current_weapon = 16;
		self.items_allowed = 16 | 256 | 128;
		self.cutf_items = 2;

		// set the weapon icons on the status bar
		self.items = 0;
		//kill_my_demons();
	}
	else if ( self.playerclass == 8 )
	{
		self.weapons_carried = self.weapons_carried | 16 | 262144 | 256 | 512/* | 1*/;
		self.ammo_rockets = 0;
		self.ammo_nails = 25;
		self.ammo_shells = 40;
		self.ammo_cells = 100;
		self.maxammo_rockets = 15;
		self.maxammo_nails = 50;
		self.maxammo_shells = 40;
		self.maxammo_cells = 200;
	
		self.no_grenades_1 = 4;
		self.no_grenades_2 = 2;
		self.tp_grenades_1 = 1;
		self.tp_grenades_2 = 7;
		self.tf_items = 65536 | 131072;
		self.job = self.job | 256;

		self.armorclass = self.armorclass | 0;
		self.armortype = 0.6;
		self.armorvalue = 50;
		self.armor_allowed = 0.6;
		self.maxarmor = 100;
		self.current_weapon = 262144;
		self.items_allowed = 16 | 262144 | 256 | 512/* | 1*/;
		self.cutf_items = 4 | 2;

		// set the weapon icons on the status bar
		self.items = self.items | 1 | 2 | 4;
		

		// If the Spy only has invis, start the Spy's cell regen timer
		if (invis_only == 1)
		{
			te = spawn();
			te.nextthink = time + 0.05;
			te.think = TeamFortress_RegenerateCells;
			te.owner = self;
			te.classname = "timer";
		}
	}
	else if ( self.playerclass == 9 )
	{
		self.weapons_carried = self.weapons_carried | 8 | 524288 | 256 | 16777216;
		self.ammo_rockets = 0;
		self.ammo_nails = 25;
		self.ammo_shells = 30;
		self.ammo_cells = 200;
		self.maxammo_rockets = 30;
		self.maxammo_nails = 50;
		self.maxammo_shells = 75;
		self.maxammo_cells = 275;
	
		self.no_grenades_1 = 4;
		self.no_grenades_2 = 4;
		self.tp_grenades_1 = 1;
		self.tp_grenades_2 = 8;
		self.tf_items = 32768 | 65536 | 131072;
		self.job = self.job | 256;

		self.armorclass = self.armorclass | 0;
		self.armortype = 0.3;
		self.armorvalue = 75;
		self.armor_allowed = 0.6;
		self.maxarmor = 75;
		self.current_weapon = 524288;
		self.items_allowed = 8 | 524288 | 256 | 16777216;
		self.cutf_items = 16 | 1024 | 256 | 524288;

		// set the weapon icons on the status bar
		self.items = self.items | 1 | 2;
		//kill_my_demons();
	}
	else if ( self.playerclass == 0 )
	{
		self.items = 0;
		self.ammo_rockets = 0;
		self.ammo_nails = 0;
		self.ammo_shells = 0;
		self.ammo_cells = 0;

		self.no_grenades_1 = 0;
		self.no_grenades_2 = 0;
		self.tp_grenades_1 = 0;
		self.tp_grenades_2 = 0;
	
		self.armorclass = 0;
		self.armortype = 0;
		self.armorvalue = 0;
		self.weapon = 0;
		self.current_weapon = 0;
		self.weapons_carried = 0;

		self.flags = 8 | 128; // | #FL_ONGROUND;
		self.waterlevel = 3;
		self.takedamage = 0;
		self.solid = 0;
		self.movetype = 8;

		self.model = string_null;
		self.mdl = string_null;
		self.modelindex = 0;
		self.weaponmodel = string_null;
		modelindex_player = 0;
		self.tfstate = self.tfstate | 2;
	
		setmodel(self, string_null);
	}

// if in coop mode, give them the max

	if ( !deathmatch ) {
		self.armorvalue = self.maxarmor;
		self.ammo_shells = self.maxammo_shells;
		self.ammo_nails = self.maxammo_nails;
		self.ammo_rockets = self.maxammo_rockets;
		self.ammo_cells = self.maxammo_cells;
	}

	
	/*if (stock_mode==1) //- OfN - Stock classes don't get a job when stock_mode is 1
		self.job=0;*/

	//- OfN - Set initial grens number
	self.no_grenades_1 = GetMaxGrens(self,1);
	self.no_grenades_2 = GetMaxGrens(self,2);	
	
	if (!(self.job & 128) && !(self.job & 4))
		kill_my_demons();
	
	// Initialize any job stuff if needed
	InitJobStuff();
		
	// Give normal classes the hook
	// Custom classes get it in 'drop into custom class gen'
	if (allow_hook && self.playerclass != 0 && self.playerclass != 11)
		self.weapons_carried = self.weapons_carried | 1;

	// Restore our original items if needed
	if (self.playerclass == 11)
		RestoreOriginalItems(self);
	else
		ResetStripedAndGiven(self);
	
	// Remove disallowed items on player, if any
	StripDisallowed(self);
	// Give free items, if any
	GiveFreeStuff(self);
	
	W_SetCurrentAmmo ();
};

//=========================================================================
// Return the max amount of ammo the Retriever can carry, based on his class
float(entity Retriever, float AmmoType) TeamFortress_GetMaxAmmo =
{
	if (AmmoType == 256)
		return Retriever.maxammo_shells;
	else if (AmmoType == 512)
		return Retriever.maxammo_nails;
	else if (AmmoType == 2048)
		return Retriever.maxammo_cells;
	else if (AmmoType == 1024)
		return Retriever.maxammo_rockets;
	else if (AmmoType == 4)
		return Retriever.maxammo_medikit;
	else if (AmmoType == 131072) //WK Used to be #WEAP_DETPACK
		return Retriever.maxammo_detpack;

	RPrint("Error in TeamFortress_GetMaxAmmo()\n");
	RPrint("Invalid ammo type passed.\n");
	return 0;
};

//=========================================================================
// Return 1 if the Retriever is allowed to pick up the Weapon
float(entity Retriever, float WeaponType) TeamFortress_CanGetWeapon =
{
	if ( Retriever.items_allowed & WeaponType )
		return 1;

	return 0;
};


//=========================================================================
// Print a string to Player, describing this type of armor
//CH returns number effected
float(entity Player, float Armorclass) TeamFortress_DescribeArmor =
{
	//local string st;
	local float num;
	num = 0;
	if (Armorclass == 0)
		return num;

	if (Armorclass & 16) {
		sprint (Player, 2, "Asbestos ");
		num = num + 1;
	}
	if (Armorclass & 4) {
		sprint (Player, 2, "Blast ");
		num = num + 1;
	}
	if (Armorclass & 8) {
		sprint (Player, 2, "Ceramic ");
		num = num + 1;
	}
	if (Armorclass & 2) {
		sprint (Player, 2, "Gel ");
		num = num + 1;
	}
	if (Armorclass & 1) {
		sprint (Player, 2, "Kevlar ");
		num = num + 1;
	}

	sprint (Player, 2, "armor");
	return num;
};

//=========================================================================
// Controls the equipment a class receives from backpacks
float(entity Retriever, entity Items) TeamFortress_AddBackpackItems =
{
	// If you want the classes to _not_ start off with all their legal
	// weapons, then you may want them to be able to pick up weapons
	// from backpacks. If so, this is where to do it.
	// For now, return. 
	return 0;	// Gizmo - what is this suppose to be returning?
};

//=========================================================================
// Return a string containing the class name for pc
string(float pc) TeamFortress_GetClassName =
{
	if ( pc == 1 )
		return "Scout";
	else if ( pc == 2 )
		return "Sniper";
	else if ( pc == 3 )
		return "Soldier";
	else if ( pc == 4 )
		return "Demolitions Man";
	else if ( pc == 5 )
		return "Combat Medic";
	else if ( pc == 6 )
		return "Heavy Weapons Guy";
	else if ( pc == 7 )
		return "Pyro";
	else if ( pc == 8 )
		return "Spy";
	else if ( pc == 9 )
		return "Engineer";
	else if ( pc == 12 )
		return "Civilian";
	else if ( pc == 0 )
		return "Observer";
	else if ( pc == 10)
		return "Random Playerclass";
	else if ( pc == 11)
		return "Custom Playerclass";
return; //comperr
};

//=========================================================================
// Return a string containing the class name for pc
string(float pc) TeamFortress_GetJobName =
{
	if ( pc & 1 )
		return "Thief";
	else if ( pc & 2 )
		return "Runner";
	else if ( pc & 4 )
		return "Warlock";
	else if ( pc & 8 )
		return "Combat Chaplan";
	else if ( pc & 16 )
		return "Nordish Berserker";
	else if ( pc & 32 )
		return "Communist Rebel";
	else if ( pc & 64 )
		return "Judo Black Belt";
	else if ( pc & 128 )
		return "Army Officer";
	else if ( pc & 256 )
		return "Hacker";
	else if ( pc & 512 )
		return "Martyr";
	else if ( pc & 1024 )
		return "Crusader";
	else
		return "Custom Playerclass";
};

//=========================================================================
// Display the class of Player to Viewer
void(entity Viewer, float pc, float rpc) TeamFortress_PrintClassName =
{
	local string st;
	st = TeamFortress_GetClassName(pc);
	sprint (Viewer, 2, st);

	if (rpc != 0)
		sprint (Viewer, 2, " (Random)");
	sprint (Viewer, 2, "\n");
};

//=========================================================================
// Display the job of a custom class to Viewer
void(entity Viewer, float pc) TeamFortress_PrintJobName =
{
	local string st;
	st = TeamFortress_GetJobName(pc);
	sprint (Viewer, 2, st);
	sprint (Viewer, 2, "\n");
};

//=========================================================================
// Say the class of Player to him/her


























//=========================================================================
// Remove all the timers for this player
// This function is _always_ called when a player dies.
void() TeamFortress_RemoveTimers =
{
	local entity te;
	local entity oself;

	self.leg_damage = 0;
	self.is_undercover = 0;
	self.is_building = 0;
	self.building = world;

	//CH - TOFIX: IS THIS WHAT CAUSES GRENS TO BE TRHOWN AFTER RESPAWNING??
	//stuffcmd (self, "throwgren\n"); //Throw any grenades
	TeamFortress_ThrowGrenade();

	if (self.tfstate & 1024)
	{
		oself = self;

		te = find(world,classname,"grenade");

		while (te)
		{
			if (te.owner == oself)
			if (te.think == TeamFortress_GrenadePrimed)
			{
				self = te;
				TeamFortress_GrenadePrimed();
			}

			te = find(te,classname,"grenade");
		}

		self = oself;
	}
	//stuffcmd (self, "impulse 169\n"); //Stop laying dets

	TeamFortress_DetpackStop(0);

	// Clear the sniper's aiming
	if (self.tfstate & 2048)
	{
		self.tfstate = self.tfstate - 2048;
		TeamFortress_SetSpeed(self);
		self.heat = 0;
	}

	// Remove all the timer entities for this player
	te = find(world, classname, "timer");
	while (te != world)
	{
		//WK Judokatimer is a little weird
		if (te.netname == "judokatimer" && te.think == JudokaRearm)
		{
			if (te.owner == self || te.enemy == self)
			{
				oself = self;
				self = te;
				self.think();
				self = oself;
				te.think = SUB_Remove;
				te.nextthink = time + 0.1;
			}
			te = find(te, classname, "timer");
		}
		else if (te.owner == self)
		{
			//WK Fix our new little flash timer
			if (te.netname == "flashtimer")
			{
				self.FlashTime = 0;
				stuffcmd(self, "v_cshift 0\n");
				stuffcmd(self, "r_norefresh 0;wait;echo;wait;echo;wait;echo;wait;echo\n");
				dremove(te);
				te = find(te, classname, "timer");
			}
			//WK Support for the curse timer
			else if (te.netname == "bastardtimer")
			{
				if (self.is_connected == 0)
				{
					// Bastard Memory
					// Only remove if the player has completed penance time. -Pulseczar
					if (self.penance_time <= time)
					{
						delstr(te.t_s_h);
						dremove(te);
					}
					// Otherwise, store their penance time in the bastard timer. -PZ
					else
					{
						te.penance_time = self.penance_time;
						te.owner = world;
					}
				}
				te = find(te, classname, "timer");
			}
			else if (te.netname == "alias") // Ignore alias timer
			{
				// do nothing, just skip it (IT MUST NOT BE REMOVED EVER)
				te = find(te, classname, "timer");
			}
			else
			{
				dremove(te);
				te = find(te, classname, "timer");
			}
		}
		else
			te = find(te, classname, "timer");
	}

	// Drop any GoalItems
	te = find (world, classname, "item_tfgoal");
	while (te)
	{
		if (te.owner == self)
		{
			// Remove it from the player, if it is supposed to be
			if (!(te.goal_activation & 256))
			{
				tfgoalitem_RemoveFromPlayer(te, self, 0);
			}

			// CTF support
			if (CTF_Map == 1 && te.goal_no == 1)
			{
				bprint(2, self.netname);
				bprint(2, " ΜΟΣΤ the ΒΜΥΕ flag!\n");
			}
			else if (CTF_Map == 1 && te.goal_no == 2)
			{
				bprint(2, self.netname);
				bprint(2, " ΜΟΣΤ the ΕΔ flag!\n");
			}

		}
		te = find(te, classname, "item_tfgoal");
	}

	// Reset detpacks being disarmed to not being disarmed
	te = find (world, classname, "detpack");
	while (te)
	{
		if ((te.weaponmode == 1) && (te.enemy == self))
		{
			te.weaponmode = 0;
		}
		te = find(te, classname, "detpack");
	}

	// detonate all of the players pipebombs
	TeamFortress_DetonatePipebombs();

	// OfN Remove holo if player dies! 
	if (self.has_holo > 0) RemoveHolo(self);

	stuffcmd(self, "v_idlescale 0\n");
	stuffcmd(self, "v_cshift 0 0 0 0\n");
	self.item_list = 0;
	self.FlashTime = 0;

	// Remove Menu
	CenterPrint(self, "\n");
	self.menu_count = 25;
	self.current_menu = 1;
	self.impulse = 0;
};

//=========================================================================
// Setup the Respawn delays for this player
void(float Suicided) TeamFortress_SetupRespawn =
{
	local float restime;//,teamsup;
	local string db;

	if (self.respawn_time > time)
		return; 	// already respawning

	// Setup Respawn Delay
	if (toggleflags & 4)
		restime = respawn_delay_time;
	else 
		restime = 0;

	// PZ - respawn delay for blue players in AGR
	//if (agr && self.team_no == 1 && !restime)
		//restime = 5;

// Gizmo - remove respawn delay for coop, TODO: enable a toggleable amount in localinfo

	if ( deathmatch ) {
		// Suiciders can't respawn immediately
		if (Suicided)
			restime = restime + 10;
	}






	// Remove a life
	if (self.lives > 0 && prematch < time)
	{
		self.lives = self.lives - 1;
/*		if (self.team_no == 1) team1total = team1total - 1;
		else if (self.team_no == 2) team1total = team2total - 1;
		else if (self.team_no == 3) team1total = team3total - 1;
		else if (self.team_no == 4) team1total = team4total - 1;*///- ???
		
		
	}

	if (self.lives != -1)
	{
		if (self.lives == 0)
		{
			// Move to Observer mode when you die
			PlayerObserverMode();
			//if (livesperguy > 1)
			//{
				sprint (self, 2, "NO lives left, returning to Observer mode.\n");
				bprint (1, self.netname);
				bprint (1, " ran out of lives!\n");
			//}
			return;
		}

		if (self.lives == 1)
			sprint (self, 2, "LAST life.\n");
		else
		{
			db = ftos(self.lives);
			sprint(self, 2, db);
			sprint (self, 2, " lives left.\n");
		}
	}//*/// ???

	// Do this after life calculation, so people without any
	// lives left can respawn back to Observer mode without a delay.
	self.respawn_time = time + restime;

	if (restime > 3)
	{
		db = ftos(restime);

		sprint(self, 2, db);
		sprint(self, 2, " seconds till respawn.\n");
	}
};

//=========================================================================
// Check all stats to make sure they're good for this class
void() TeamFortress_CheckClassStats =
{
	// Check armor
	if (self.armortype > self.armor_allowed)
		self.armortype = self.armor_allowed;
	if (self.armorvalue > self.maxarmor)
		self.armorvalue = self.maxarmor;
	if (self.armortype < 0)
		self.armortype = 0;
	if (self.armorvalue < 0)
		self.armorvalue = 0;
	// Check ammo
	if (self.ammo_shells > TeamFortress_GetMaxAmmo(self,256))
		self.ammo_shells = TeamFortress_GetMaxAmmo(self,256);
	if (self.ammo_shells < 0)
		self.ammo_shells = 0;
	if (self.ammo_nails > TeamFortress_GetMaxAmmo(self,512))
		self.ammo_nails = TeamFortress_GetMaxAmmo(self,512);
	if (self.ammo_nails < 0)
		self.ammo_nails = 0;
	if (self.ammo_rockets > TeamFortress_GetMaxAmmo(self,1024))
		self.ammo_rockets = TeamFortress_GetMaxAmmo(self,1024);		
	if (self.ammo_rockets < 0)
		self.ammo_rockets = 0;
	if (self.ammo_cells > TeamFortress_GetMaxAmmo(self,2048))
		self.ammo_cells = TeamFortress_GetMaxAmmo(self,2048);		
	if (self.ammo_cells < 0)
		self.ammo_cells = 0;
	if (self.ammo_medikit > TeamFortress_GetMaxAmmo(self,4))
		self.ammo_medikit = TeamFortress_GetMaxAmmo(self,4);		
	if (self.ammo_medikit < 0)
		self.ammo_medikit = 0;
	if (self.ammo_detpack > TeamFortress_GetMaxAmmo(self,131072))
		self.ammo_detpack = TeamFortress_GetMaxAmmo(self,131072);		
	if (self.ammo_detpack < 0)
		self.ammo_detpack = 0;
	// Check Grenades
	if (self.no_grenades_1 < 0)
		self.no_grenades_1 = 0;
	if (self.no_grenades_2 < 0)
		self.no_grenades_2 = 0;
	// Check health
	if (self.health > self.max_health && !(self.items & 65536))
		TF_T_Damage (self, world, world, (self.max_health - self.health), 0, 256);
	if (self.health < 0)
		T_Heal(self, (self.health - self.health), 0);

	// Update armor picture
	self.items = self.items - (self.items & (8192 | 16384 | 32768));
	if (self.armortype >= 0.8)
		self.items = self.items | 32768;
	else if (self.armortype >= 0.6)
		self.items = self.items | 16384;
	else if (self.armortype >= 0.3)
		self.items = self.items | 8192;
};

//=========================================================================
// AMMOBOX Handling
//=========================================================================
// Throw an ammo box with 10 shells, 10 nails, 5 cells or 5 rockets
void (float type) TeamFortress_DropAmmo =
{
	local float ammo;

	if (type == 1)
	{
		ammo = 20;
		if (self.ammo_shells < ammo)
		{
/*CH who cares, we need space
			// ENGINEER can make ammo
			if (self.playerclass == #PC_ENGINEER)
			{
				if ((self.ammo_cells / #AMMO_COST_SHELLS) > (ammo - self.ammo_shells))
				{
					sprint (self, #PRINT_HIGH, "you make some shells.\n");
					self.ammo_cells = self.ammo_cells - ((ammo - self.ammo_shells) * #AMMO_COST_SHELLS);
					self.ammo_shells = ammo;
				}
			}

			if (self.ammo_shells < ammo)
*/				return;
		}

		self.ammo_shells = self.ammo_shells - ammo;
	}
	else if (type == 2)
	{
		ammo = 20;
		if (self.ammo_nails < ammo)
		{
/*CH who cares, we need space
			// ENGINEER can make ammo
			if (self.playerclass == #PC_ENGINEER)
			{
				if ((self.ammo_cells / #AMMO_COST_NAILS) > (ammo - self.ammo_nails))
				{
					sprint (self, #PRINT_HIGH, "you make some nails.\n");
					self.ammo_cells = self.ammo_cells - ((ammo - self.ammo_nails) * #AMMO_COST_NAILS);
					self.ammo_nails = ammo;
				}
			}

			if (self.ammo_nails < ammo)
*/				return;
		}

		self.ammo_nails = self.ammo_nails - ammo;
	}
	else if (type == 3)
	{
		ammo = 10;
		if (self.ammo_rockets < ammo)
		{
/*CH who cares, we need space
			// ENGINEER can make ammo
			if (self.playerclass == #PC_ENGINEER)
			{
				if ((self.ammo_cells / #AMMO_COST_ROCKETS) > (ammo - self.ammo_rockets))
				{
					sprint (self, #PRINT_HIGH, "you make some rockets.\n");
					self.ammo_cells = self.ammo_cells - ((ammo - self.ammo_rockets) * #AMMO_COST_ROCKETS);
					self.ammo_rockets = ammo;
				}
			}

			if (self.ammo_rockets < ammo)
*/				return;
		}

		self.ammo_rockets = self.ammo_rockets - ammo;
	}
//	else if (type == 4)
	else
	{
		ammo = 10;
		if (self.ammo_cells < ammo)
		{
/*CH who cares, we need space
			// ENGINEER can make ammo
			if (self.playerclass == #PC_ENGINEER)
			{
				if ((self.ammo_cells / #AMMO_COST_CELLS) > (ammo - self.ammo_cells))
				{
					sprint (self, #PRINT_HIGH, "you make some cells.\n");
					self.ammo_cells = self.ammo_cells - ((ammo - self.ammo_cells) * #AMMO_COST_CELLS);
					self.ammo_cells = ammo;
				}
			}

			if (self.ammo_cells < ammo)
*/				return;
		}

		self.ammo_cells = self.ammo_cells - ammo;
	}
	W_SetCurrentAmmo();

	if (self.team_no != 0)
	{
		increment_team_ammoboxes(self.team_no);
		if (num_team_ammoboxes(self.team_no) > (6 / number_of_teams))
			RemoveOldAmmobox(self.team_no);
	}
	else 
	{
		num_world_ammoboxes = num_world_ammoboxes + 1;
		if (num_world_ammoboxes > 6)
			RemoveOldAmmobox(0);
	}

	newmis = spawn();
	newmis.aflag = ammo;
	newmis.weapon = type;
	if (newmis.weapon == 1)
		newmis.ammo_shells = ammo;
	else if (newmis.weapon == 2)
		newmis.ammo_nails = ammo;
	else if (newmis.weapon == 3)
		newmis.ammo_rockets = ammo;
	else if (newmis.weapon == 4)
		newmis.ammo_cells = ammo;
	newmis.enemy = self;
	newmis.health = time;
	newmis.movetype = 6;
	newmis.solid = 1;
	newmis.classname = "ammobox";
	newmis.team_no = self.team_no;

	makevectors (self.v_angle);

	if (self.v_angle_x)
		newmis.velocity = v_forward*400 + v_up * 200;
	else
	{
		newmis.velocity = aim(self, 10000);
		newmis.velocity = newmis.velocity * 400;
		newmis.velocity_z = 200;
	}

	newmis.avelocity = '0 300 0';
	setsize (newmis, '0 0 0', '0 0 0'); 	
	setorigin (newmis, self.origin);
	newmis.nextthink = time + 30;	// remove after 30 seconds
	newmis.think = SUB_Remove;
	newmis.touch = TeamFortress_AmmoboxTouch;
	newmis.skin = type - 1;
	setmodel (newmis, "progs/ammobox.mdl");
};

void () TeamFortress_AmmoboxTouch =
{
	local string quantity;

	// Gizmo - added this to prevent things messing up
	if ( other.button0 )
		return;

	// Cant touch own ammobox for 2 seconds after throwing
	if ((other == self.enemy) && (time < self.health + 2))
		return; 		

	if (other.health <= 0)
		return;

	
	// Return if other is not a player
	if (other.classname != "player") //- OfN - Now grunt can take em
	{
		if (other.classname != "monster_army") return;

		num_world_ammoboxes = num_world_ammoboxes - 1;
		decrement_team_ammoboxes(self.team_no);

		other.ammo_shells = other.ammo_shells + self.ammo_shells;
		other.ammo_nails = other.ammo_nails + self.ammo_nails;
		other.ammo_rockets = other.ammo_rockets + self.ammo_rockets;
		other.ammo_cells = other.ammo_cells + self.ammo_cells;

		grunty_boundammo(other);

		PrintFromSoldier(other,other.real_owner,"i picked up some ammo.\n",1);

		sound (other, 3, "weapons/lock4.wav", 1, 1);

		dremove(self);
		self = other;

		return;
	}

	num_world_ammoboxes = num_world_ammoboxes - 1;
	decrement_team_ammoboxes(self.team_no);

	// discard backpack
	if (self.weapon == 0)
	{
		sprint(other, 0, "You got ");
		if (self.ammo_shells > 0)
		{
			other.ammo_shells = other.ammo_shells + self.ammo_shells;
			quantity = ftos(self.ammo_shells);
			sprint2(other, 0, quantity, " shells  ");
		}	
		if (self.ammo_nails > 0)
		{
			other.ammo_nails = other.ammo_nails + self.ammo_nails;
			quantity = ftos(self.ammo_nails);
			sprint2(other, 0, quantity, " nails  ");
		}	
		if (self.ammo_rockets > 0)
		{
			other.ammo_rockets = other.ammo_rockets + self.ammo_rockets;
			quantity = ftos(self.ammo_rockets);
			sprint2(other, 0, quantity, " rockets  ");
		}	
		if (self.ammo_cells > 0)
		{
			other.ammo_cells = other.ammo_cells + self.ammo_cells;
			quantity = ftos(self.ammo_cells);
			sprint2(other, 0, quantity, " cells  ");
		}	
		sprint(other, 0, "\n");
	}
	// shotgun
	else if (self.weapon == 1)
	{
		if (other.ammo_shells >= TeamFortress_GetMaxAmmo(other,256))
			return;
		other.ammo_shells = other.ammo_shells + self.aflag;
		self.netname = "shells";
	}
	// spikes
	else if (self.weapon == 2)
	{
		if (other.ammo_nails >= TeamFortress_GetMaxAmmo(other,512))
			return;
		other.ammo_nails = other.ammo_nails + self.aflag;
		self.netname = "nails";
	}
	//	rockets
	else if (self.weapon == 3)
	{
		if (other.ammo_rockets >= TeamFortress_GetMaxAmmo(other,1024))
			return;
		other.ammo_rockets = other.ammo_rockets + self.aflag;
		self.netname = "rockets";
	}
	//	cells
	else if (self.weapon == 4)
	{
		if (other.ammo_cells >= TeamFortress_GetMaxAmmo(other,2048))
			return;
		other.ammo_cells = other.ammo_cells + self.aflag;
		self.netname = "cells";
	}

	bound_other_ammo (other);

	// Discard backpacks do their own printing
	if (self.weapon > 0)
	{
		quantity = ftos(self.aflag);
		sprint5(other, 0, "You picked up ", quantity, " ", self.netname, "\n");
	}

	sound (other, 3, "weapons/lock4.wav", 1, 1);
	stuffcmd (other, "bf\n");

	dremove(self);
	self = other;
	W_SetCurrentAmmo();
};

// Return the number of pipebombs in existence for a particular team
float (float tno) num_team_ammoboxes =
{
	if (tno == 1)
		return num_team_ammoboxes_1;
	else if (tno == 2)
		return num_team_ammoboxes_2;
	else if (tno == 3)
		return num_team_ammoboxes_3;
	else if (tno == 4)
		return num_team_ammoboxes_4;

	return 0;
};

// Remove enough old ammoboxes to bring the count down to the max level
void(float tno) RemoveOldAmmobox =
{
	local entity old;
	local float index;

	if (tno != 0)
	{
		index = num_team_ammoboxes(tno);
		index = index - (6 / number_of_teams);
	}
	else
	{
		index = num_world_ammoboxes - 6;
	}

	old = find(world, classname, "ammobox");
	while (index > 0)
	{
		if (old == world)
		{
//			RPrint("*** ERROR: RemoveOldAmmobox. ***\n");
//			RPrint("*** Shaka thought he fixed this ***\n");
			num_world_ammoboxes = num_world_ammoboxes - 1;
			decrement_team_ammoboxes(old.team_no);
			return;
		}

		if (old.team_no == tno || tno == 0)
		{
			old.think = SUB_Remove;
			old.nextthink = time + 0.1;
			index = index - 1;

			num_world_ammoboxes = num_world_ammoboxes - 1;
			decrement_team_ammoboxes(old.team_no);
		}

		old = find(old, classname, "ammobox");
	}
};

void(float tno) increment_team_ammoboxes =
{
	if (tno == 1)
		num_team_ammoboxes_1 = num_team_ammoboxes_1 + 1;
	else if (tno == 2)
		num_team_ammoboxes_2 = num_team_ammoboxes_2 + 1;
	else if (tno == 3)
		num_team_ammoboxes_3 = num_team_ammoboxes_3 + 1;
	else if (tno == 4)
		num_team_ammoboxes_4 = num_team_ammoboxes_4 + 1;
};

void(float tno) decrement_team_ammoboxes =
{
	if (tno == 1)
		num_team_ammoboxes_1 = num_team_ammoboxes_1 - 1;
	else if (tno == 2)
		num_team_ammoboxes_2 = num_team_ammoboxes_2 - 1;
	else if (tno == 3)
		num_team_ammoboxes_3 = num_team_ammoboxes_3 - 1;
	else if (tno == 4)
		num_team_ammoboxes_4 = num_team_ammoboxes_4 - 1;
};

//=========================================================================
// WEAPON HANDLING FUNCTIONS
//=========================================================================
//=========================================================================
// Assault Cannon selection function
void() TeamFortress_AssaultWeapon =
{
	//local float	it;
	
	self.impulse = 0;

	if (self.tfstate & 2)
		return;

	if (!(self.weapons_carried & 32768)) 
		return;

	if (self.heat > 0)
	{
		sprint (self, 2, "the assault cannon is still overheated.\n");
		return;
	}

	if (self.ammo_shells < 1)
	{	// don't have the ammo
		sprint (self, 2, "not enough ammo.\n");
		return;
	}
	// The cannon also needs 6 cells to power up 
	if (self.ammo_cells < 6)
	{
		sprint (self, 2, "not enough cells to power the assault cannon.\n");
		return;
	}

	self.current_weapon = 32768;

	W_SetCurrentAmmo ();
};

//=========================================================================
// If this gets called, the players holding onto an exploding grenade :)
void() TeamFortress_ExplodePerson =
{
	//local entity te;

	// Removes the owners grenade
	self.owner.tfstate = self.owner.tfstate - (self.owner.tfstate & 1);

	KickPlayer(-2, self.owner);

	newmis = spawn ();
	newmis.movetype = 10;
	newmis.solid = 2;
	newmis.classname = "grenade";
	newmis.team_no = self.owner.team_no;
	newmis.owner = self.owner;
		
	// Don't bother calculating a velocity
	newmis.velocity = '0 0 0';
	newmis.angles = vectoangles(newmis.velocity);
	
	// set the grenades thinktime to now
	newmis.think = SUB_Null;
	newmis.nextthink = time + 0.1;

	// set the think and touches to the appropriate grenade type
	if (self.weapon == 1)
	{
		newmis.touch = NormalGrenadeTouch;
		newmis.think = NormalGrenadeExplode;
		newmis.skin = 0;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	else if (self.weapon == 2)
	{
		newmis.touch = ConcussionGrenadeTouch;
		newmis.think = ConcussionGrenadeExplode;
		newmis.skin = 1;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	else if (self.weapon == 13)
	{
		newmis.touch = BioGrenadeTouch;
		newmis.think = BioGrenadeExplode;
		newmis.skin = 0;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	else if (self.weapon == 12)
	{
		newmis.touch = ConcussionGrenadeTouch;
		newmis.think = AntiGravGrenadeExplode;
		newmis.skin = 1;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	else if (self.weapon == 3)
	{
		newmis.touch = NailGrenadeTouch;
		newmis.think = NailGrenadeExplode;
		newmis.skin = 1;
		newmis.avelocity = '0 300 0';
		setmodel (newmis, "progs/biggren.mdl");
	}
	else if (self.weapon == 14)
	{
		newmis.touch = NormalGrenadeTouch;
		newmis.think = CaltropGrenadeExplode;
		newmis.skin = 0;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	else if (self.weapon == 4)
	{
		newmis.touch = MirvGrenadeTouch;
		newmis.think = MirvGrenadeExplode;
		newmis.skin = 0;
		newmis.avelocity = '0 300 0';
		setmodel (newmis, "progs/biggren.mdl");
	}
	else if (self.weapon == 5)
	{
		newmis.touch = NapalmGrenadeTouch;
		newmis.think = NapalmGrenadeExplode;
		newmis.skin = 2;
		newmis.avelocity = '0 300 0';
		setmodel (newmis, "progs/biggren.mdl");
	}
//CH no flare 
//OfN why??
	else if (self.weapon == 6)
	{
		//sprint(self.owner, #PRINT_HIGH, "Flare lit.\n");
		sprint(self.owner, 2, "The flare burns on your hand!\n");
		deathmsg = 0; // TODO
		T_Damage(self.owner, self.owner, self.owner,12);
		stuffcmd(self.owner, "bf\nbf\n");

		newmis.touch = FlareBounce;
		newmis.think = FlareGrenadeExplode;
		newmis.skin = 0;
		newmis.has_holo=1;
		newmis.avelocity = '0 0 0';
		setmodel (newmis, "progs/flarefly.mdl");

		/*te = spawn();
		te.touch = SUB_Null;
		te.think = SUB_Remove;//FlareGrenadeExplode;//RemoveFlare;
		te.nextthink = time + 25;
		te.owner = self.owner;
		te.solid = #SOLID_NOT;
		self.owner.effects = self.owner.effects | #EF_BRIGHTLIGHT;*/

		setsize (newmis, '0 0 0', '0 0 0'); 	
		setorigin (newmis, self.owner.origin);

		
		dremove(self);
		//dremove(newmis);
		return;
	}
	else if (self.weapon == 7)
	{
		newmis.touch = GasGrenadeTouch;
		newmis.think = GasGrenadeExplode;
		newmis.skin = 2;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/grenade2.mdl");
	}
	else if (self.weapon == 8)
	{
		newmis.touch = EMPGrenadeTouch;
		newmis.think = EMPGrenadeExplode;
		newmis.skin = 4;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/grenade2.mdl");
	}
	









	else if (self.weapon == 9)
	{
		newmis.touch = PsionicGrenadeTouch;
		newmis.think = PsionicGrenadeExplode;
		newmis.skin = 1;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/grenade2.mdl");
	}
	
	else if (self.weapon == 10)
	{
		newmis.touch = FragGrenadeTouch;
		newmis.think = FragGrenadeExplode;
		newmis.skin = 1;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/grenade2.mdl");
	}
	else if (self.weapon == 11)
	{
		newmis.touch = KracGrenadeTouch;
		newmis.think = KracGrenadeExplode;
		newmis.skin = 1;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/grenade2.mdl");
	}

	setsize (newmis, '0 0 0', '0 0 0'); 	
	setorigin (newmis, self.owner.origin);

	//bprint(#PRINT_MEDIUM, "No ");
	//bprint(#PRINT_MEDIUM, self.owner.netname);
	//bprint(#PRINT_MEDIUM, ", throw the grenade, not the pin!\n");

	bprint(1, "No ");
	bprint(1, self.owner.netname);
	bprint(1, ", you are supposed to THROW the grenade!\n");

	//no xxx, your grenade is your friend for another reason!
	//no

	// Remove primed grenade object 
	dremove(self);
};

//=========================================================================
// Thrown Grenade touch function.
void() NormalGrenadeTouch =
{
	if (other == self.owner)
		return; 	// don't explode on owner

	// Thrown grenades don't detonate when hitting an enemy

	sound (self, 1, "weapons/bounce.wav", 1, 1);	// bounce sound
	if (self.velocity == '0 0 0')
		self.avelocity = '0 0 0';
};

//=========================================================================
// Thrown grenade explosion. 50% more powerful as grenade launcher grenades.
void() NormalGrenadeExplode =
{
	deathmsg = 8;
	T_RadiusDamage (self, self.owner, 180, world);







	WriteByte (4, 23);
	WriteByte (4, 3);
	WriteCoord (4, self.origin_x);
	WriteCoord (4, self.origin_y);
	WriteCoord (4, self.origin_z);

	multicast (self.origin, 1);
	dremove(self);



};

//=========================================================================
// Displays the state of the items in the Detection Entity
void() TeamFortress_DisplayDetectionItems =
{
	local entity Goal, te;

	Goal = find(world, classname, "info_tfdetect");
	if (!Goal)
		return;

	// Check to make sure they've got some strings
	if (Goal.team_str_home == string_null)
		return;

	if (Goal.display_item_status1 != 0)
	{
		te = Finditem(Goal.display_item_status1);
		if (te)
			DisplayItemStatus(Goal, self, te);
		else
			sprint (self, 2, "Item is missing.\n");
	}
	else
		return;

	if (Goal.display_item_status2 != 0)
	{
		te = Finditem(Goal.display_item_status2);
		if (te)
			DisplayItemStatus(Goal, self, te);
		else
			sprint (self, 2, "Item is missing.\n");
	}
	else
		return;

	if (Goal.display_item_status3 != 0)
	{
		te = Finditem(Goal.display_item_status3);
		if (te)
			DisplayItemStatus(Goal, self, te);
		else
			sprint (self, 2, "Item is missing.\n");
	}
	else
		return;

	if (Goal.display_item_status4 != 0)
	{
		te = Finditem(Goal.display_item_status4);
		if (te)
			DisplayItemStatus(Goal, self, te);
		else
			sprint (self, 2, "Item is missing.\n");
	}
};

//=========================================================================
// ITEM HANDLING FUNCTIONS
//=========================================================================
// Function for handling the BioInfection Decay of players
void() BioInfection_Decay =
{
	// Remove infections which can't hurt the owner
	if ((teamplay & 16) && Teammate(self.owner.team_no,self.enemy.team_no))
	{
		self.owner.tfstate = self.owner.tfstate - (self.owner.tfstate & 16);
		dremove(self);
		return;
	}

	if (self.invincible_finished > time)
	{
		self.owner.tfstate = self.owner.tfstate - (self.owner.tfstate & 16);
		dremove(self);
		return;
	}

	if (self.owner.current_weapon == 4)
	{
		sprint(self.owner,2,"You heal yourself of your infection.\n");
		self.owner.tfstate = self.owner.tfstate - (self.owner.tfstate & 16);
		dremove(self);
		return;
	}

	// remove this entity if the infection is gone
	if ( !(self.owner.tfstate & 16) )
	{
		dremove(self);
		return;
	}

	self.nextthink = time + 2;

	deathmsg = 13;
	TF_T_Damage(self.owner, self, self.enemy, 5, 1, 0);

	SpawnBlood(self.owner.origin, 30);	
};

//========================================================================
// Function for handling the BioInfection Decay of monsters
void() BioInfection_MonsterDecay =
{
	local float drmg;

	if (!self.enemy)
	{
		dremove(self);
		return;
	}

	if (!(self.enemy.tfstate & 16)) {
		dremove(self);
		return;
	}

	if (self.enemy.health <= 0)
	{
		dremove(self);
		return;
	}

	drmg = 125 * random(); // was 200
	drmg = drmg * random();

	self.nextthink = time + 2;

	if (self.enemy.health + 30 < drmg)
		drmg = self.enemy.health + 29;

	//T_Damage(self.enemy, self, self.owner, drmg);

	if ( COOP_IsCoopMonster( self.enemy ) )
		deathmsg = 13;

	TF_T_Damage(self.enemy, self, self.owner, drmg, 32,0);

	SpawnBlood(self.enemy.origin, drmg+10);

	if (self.enemy.health > 1 && self.enemy.classname == "monster_army")
	{
		if (random() < 0.10)
		{
			local float rnum;
			rnum = random();

			if (rnum > 0.66)
				PrintFromSoldier(self.enemy,self.enemy.real_owner,"Argh! Medic!!\n",2);
			else if (rnum > 0.33)
				PrintFromSoldier(self.enemy,self.enemy.real_owner,"Are you going to heal me?\n",2);
			else
				PrintFromSoldier(self.enemy,self.enemy.real_owner,"My medikits won't cure me! Help!!\n",2);

			sound(self.enemy, 2, "speech/saveme1.wav", 1, 1);
		}
	}		
};

//=========================================================================
// UTILITY FUNCTIONS
//=========================================================================
// Stuff an alias. This is a little messy since we insisted
// on maintaining the ability to alter the impulse numbers in the defs.qc 
// and not have to change any code. 
void(string halias, float himpulse1, float himpulse2) TeamFortress_Alias =
{
	local string imp;

	stuffcmd(self, "alias ");
	stuffcmd(self, halias);
	stuffcmd(self, " \"impulse ");
	imp = ftos(himpulse1);
	stuffcmd(self, imp);

	// if himpulse2 is not zero, assume that himpulse1 is a preimpulse 
	// and complete the alias
	if (himpulse2 != 0)
	{
		stuffcmd(self, ";wait; impulse ");
		imp = ftos(himpulse2);
		stuffcmd(self, imp);
	}
	stuffcmd(self, "\"\n");
};

//=========================================================================
// CYCLIC EVENT FUNCTIONS
//=========================================================================
//=========================================================================
// Regenerates the entity which owns this cyclictimer
void() TeamFortress_Regenerate =
{
//WK	if (self.owner.playerclass == #PC_MEDIC)
	if (self.is_abouttodie)
		return;
	if (self.owner.weapons_carried & 4) //WK Custom class friendly
	{
		self.nextthink = time + 3;

		if (self.owner.health >= self.owner.max_health)
			return;

		if (self.owner.ammo_medikit == 0)
			return;

		if (self.owner.ammo_medikit < 6)
		{
			self.owner.health = self.owner.health + self.owner.ammo_medikit;
			self.owner.ammo_medikit = 0;
		}
		else
		{
			self.owner.health = self.owner.health + 6;
			self.owner.ammo_medikit = self.owner.ammo_medikit - 6;
		}

		if (self.owner.health > self.owner.max_health)
			self.owner.health = self.owner.max_health;
	}
};

void() CyberAugSleep =
{
	if (self.owner.velocity_z == 0 && self.owner.velocity_y == 0 && self.owner.velocity_x == 0)
		self.think = TeamFortress_RegenerateCyber;
	
	self.nextthink = time + 2;
};

void() TeamFortress_RegenerateCyber =
{
	local entity oself;

	if (self.is_abouttodie)
		return;
	
//WK	if (self.owner.playerclass == #PC_MEDIC)
	if (self.owner.velocity_z > 0 || self.owner.velocity_y > 0 || self.owner.velocity_x > 0)
	{
		self.nextthink = time + 2;
		self.think = CyberAugSleep;
		return;
	}

	if (self.owner.cutf_items & 128 && !(self.owner.is_malfunctioning)) //WK Custom class friendly
	{
		self.owner.armortype = self.owner.armor_allowed;
		// Gizmo - whoever did this forgot that W_SetCurrentAmmo only works on self, fixed :)
		oself = self;
		self = self.owner;
		W_SetCurrentAmmo();
		self = oself;

		if (self.owner.health < self.owner.max_health)
		{
			if (self.owner.ammo_medikit == 0)
				self.owner.health = self.owner.health + 1;
			else if (self.owner.ammo_medikit < 6 / 2)
			{
				self.owner.health = self.owner.health + self.owner.ammo_medikit * 2;
				self.owner.ammo_medikit = 0;
			}
			else
			{
				self.owner.health = self.owner.health + 6;
				self.owner.ammo_medikit = self.owner.ammo_medikit - 6 / 2;
			}
		}

		if (self.owner.armorvalue < self.owner.maxarmor)
		{
			if (self.owner.ammo_cells == 0)
				self.owner.armorvalue = self.owner.armorvalue + 2;
			else if (self.owner.ammo_cells < 6)
			{
				self.owner.armorvalue = self.owner.armorvalue + self.owner.ammo_cells * 2;
				self.owner.ammo_cells = 0;
			}
			else
			{
				self.owner.armorvalue = self.owner.armorvalue + 6 * 2;
				self.owner.ammo_cells = self.owner.ammo_cells - 6;
			}
		}

		UpdateCells(self.owner);

		if (self.owner.armorvalue > self.owner.maxarmor)
			self.owner.armorvalue = self.owner.maxarmor;
		if (self.owner.health > self.owner.max_health)
			self.owner.health = self.owner.max_health;
	}
	else if (self.owner.cutf_items & 128 && self.owner.is_malfunctioning == 1)
	{
		if (self.owner.health > 3)
			TF_T_Damage(self.owner, self.owner, self.owner, 3, 1, 0);
		else if (self.owner.health < 3 && self.owner.health > 1)
			self.owner.health = 1;
		if (self.owner.armorvalue > 3)
			self.owner.armorvalue = self.owner.armorvalue - 3;
		else if (self.owner.armorvalue < 3)
			self.owner.armorvalue = 0;
	}
	
	self.nextthink = time + 3;

};
//=========================================================================
// Activates when we go hidden
// If we're moving, make us not invis
void() TeamFortress_RegenerateCells =
{
	//WK Borrow this code from TF, since there's no reason to
	// duplicate it.
	if (!(self.owner.job & 1))
		dremove(self);
	if (!(self.owner.job & 2048))
		dremove(self);
	if (self.owner.health <= 0)
		dremove(self);
	self.nextthink = time + 0.05;
	if (self.owner.job & 2048)
	{
		/*if (self.owner.ammo_cells == 0)
		{
			RevealThief(self.owner,#FALSE);
		}
		else {	*/		
			//if (self.owner.ammo_cells > 100) self.owner.ammo_cells = 100;
		if ((self.owner.velocity_z > 0 || self.owner.velocity_y > 0 || self.owner.velocity_x > 0) && self.owner.job & 4096)
		{
				self.owner.frame = 0;
				self.owner.weaponframe = 0;
				self.owner.modelindex = modelindex_eyes;
				self.owner.job = self.owner.job - (self.owner.job & 4096);
				TeamFortress_SetSpeed(self.owner);
			/*self.owner.ammo_cells = self.owner.ammo_cells - #PC_SPY_CELL_USAGE;
			if (self.owner.ammo_cells <= 0) {
				self.owner.ammo_cells = 0;
				RevealThief(self.owner,#FALSE);*/
			
		}
		else if ((self.owner.velocity_z == 0 && self.owner.velocity_y == 0 && self.owner.velocity_x == 0) && !(self.owner.job & 4096))
		{
			self.owner.frame = 0;
			self.owner.weaponframe = 0;
			self.owner.modelindex = modelindex_null;
			self.owner.job = self.owner.job | 4096;
		}
	}
	/*else	// Increase cell ammo
	{
		if (self.owner.ammo_cells >= self.owner.maxammo_cells)
			return;

		self.owner.ammo_cells = self.owner.ammo_cells + #PC_SPY_CELL_REGEN_AMOUNT;

		if (self.owner.ammo_cells > self.owner.maxammo_cells)
			self.owner.ammo_cells = self.owner.maxammo_cells;
	}*/
	//return;

	/*
	if (self.owner.playerclass == #PC_SPY)
	{
		self.nextthink = time + #PC_SPY_CELL_REGEN_TIME;

		// If the spy is undercover, decrease the number of cells
		if (self.owner.is_undercover == 1)
		{
			// If the spy has no cells left, he becomes visible again
			if (self.owner.ammo_cells == 0)
			{
				self.owner.is_undercover = 0;
				self.owner.modelindex = modelindex_player;	// return to normal
				self.owner.items = self.owner.items - (self.owner.items & #IT_INVISIBILITY);
			}
			else // Decrease cells
			{
				self.owner.ammo_cells = self.owner.ammo_cells - #PC_SPY_CELL_USAGE;
				if (self.owner.ammo_cells < 0)
					self.owner.ammo_cells = 0;
			}
		}
		else	// Increase cell ammo
		{
			if (self.owner.ammo_cells >= self.owner.maxammo_cells)
				return;

			self.owner.ammo_cells = self.owner.ammo_cells + #PC_SPY_CELL_REGEN_AMOUNT;

			if (self.owner.ammo_cells > self.owner.maxammo_cells)
				self.owner.ammo_cells = self.owner.maxammo_cells;
		}

		return;
	}
	*/
};

//============================================================================
// sends a player to observer mode
void() PlayerObserverMode =
{
	DetonateAllGuns();
	kill_my_demons();
	self.current_menu = 1;
	self.impulse = 0;
	self.playerclass = 0;
	self.lives = 0;
	self.health = 1;
	self.gravity = 0; //WK Make em float so prediction doesn't get all annoying-like
	if (self.team_no > 0) self.old_team_no = self.team_no; //WK Save old team for scoreboard
	self.team_no = -1;

	self.flags = 8 | 128 | 512;
	self.waterlevel = 3;
	self.takedamage = 0;
	self.solid = 0;
	//self.movetype = #MOVETYPE_NOCLIP;
	self.movetype = 5;

	self.model = string_null;
	self.mdl = string_null;
	setmodel(self, string_null);

	self.velocity = '0 0 0';
	self.avelocity = '0 0 0';

	sprint (self, 2, "Observer mode\n");
	CenterPrint(self, "\n");
	stuffcmd(self, "color 0; wait; cl_rollangle 0\n");
};

//============================================================================
// Return the crossproduct of 2 vectors
float(vector veca, vector vecb) crossproduct =
{
	local float result;

	result = (veca_x * vecb_y) - (vecb_x * veca_y);
	return result;
};


