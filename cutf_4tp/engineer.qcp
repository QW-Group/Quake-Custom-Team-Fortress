/*======================================================
	ENGINEER.QC 		Custom TeamFortress v3.1	

	(c) TeamFortress Software Pty Ltd	2/3/97
	(c) William Kerney			4/14/00
	(c) Craig Hauser				4/14/00
========================================================
Weapons and functions for the ENGINEER class and associated weaponry
=======================================================*/
//comperr float modelindex_tesla; //CH
// Weapon Functions
void() LaserBolt_Touch;
void() LaserBolt_Think;
void() W_FireLaser;

// EMP Grenade Functions
void() EMPExplode;
void() EMPGrenadeTouch;
void() EMPGrenadeExplode;

// Building Functions
void() TeamFortress_EngineerBuild;
void(float objtobuild, float devicenum) TeamFortress_Build;
void() TeamFortress_FinishedBuilding;
void() T_Dispenser;
void() Dispenser_Die;
void(entity disp) Engineer_UseDispenser;
void(entity gun) Engineer_UseSentryGun;
void(entity cam) Engineer_UseCamera;
void() CheckDistance;
float(entity obj, entity builder) CheckArea;
//WK
void() Sentry_Touch;
float(float myteam) HasFlag;

//- OfN
void(entity fieldgen) FieldGen_Built;
float(entity player, float buildtype) EnoughToBuild;

//=========================================================================
// Laserbolt think function
void() LaserBolt_Think =
{
	if (time > self.heat) {
		dremove(self);	
		return;
	}	
	self.solid = 1;
	self.movetype = 9;
	self.velocity = self.oldorigin;
	self.touch = LaserBolt_Touch;
	setmodel(self, "progs/e_spike2.mdl");

	self.nextthink = time + 1.0;
	self.think = SUB_Remove;
};

//=========================================================================
// Laserbolt touch function. Just moves through the player and comes out
// the other side.
void() LaserBolt_Touch =
{
	local vector org;
	
	if (time > self.heat) {
		dremove(self);	
		return;
	}

	if (other == self.owner)
		return; 	

	if (other == self.enemy && self.enemy != world)
		return; 	// don't explode on same person twice

	if (pointcontents(self.origin) == -6)
	{
		dremove(self);
		return;
	}

	//WK Sweep mines at point of impact
	GuerillaMineSweep(self.origin);

	org = self.origin - 8*normalize(self.velocity);

	if (other.health)
	{
		SpawnBlood (org, 15);
		deathmsg = 26;
		TF_T_Damage (other, self, self.enemy, 25, 0, 8);
		self.velocity = self.oldorigin;
		self.owner = other;

		setmodel (self, string_null);
		self.touch = SUB_Null;
//		self.solid = #SOLID_NOT;
//		self.movetype = #MOVETYPE_NOCLIP;

		self.nextthink = time + 0.1;
		self.think = LaserBolt_Think;
		return;
	}
	else
	{
		//WK Fly through walls!
		setmodel (self, string_null);
		self.touch = SUB_Null;
		self.solid = 0;
		self.movetype = 8;

		self.nextthink = time + 0.1;
		self.think = LaserBolt_Think;
		return;
//comperr		WriteByte (4, 23);
//comperr		WriteByte (4, 0);
//comperr		WriteCoord (4, self.origin_x);
//comperr		WriteCoord (4, self.origin_y);
//comperr		WriteCoord (4, self.origin_z);
	
//comperr		multicast (self.origin, 1);
	
	}
	
//comperr	dremove(self);	
};

//=========================================================================
// Fire a laserbolt
//WK 1/7/7 Note: This is the railgun, not the thunderbolt, nor the lasercannon
void() W_FireLaser =
{
	local	vector	vec, org;

	self.currentammo = self.ammo_nails = self.ammo_nails - 1;

	makevectors(self.v_angle);
	org = self.origin + (v_forward * 8);
	vec = aim(self, 10000);
	vec = normalize(vec);
		
	newmis = spawn();
	newmis.owner = self;
	newmis.enemy = self;	// The real owner
	newmis.movetype = 9;
	newmis.solid = 1;

	setmodel (newmis, "progs/e_spike1.mdl");
	setsize (newmis, '0 0 0', '0 0 0'); 	

	setorigin (newmis, org + '0 0 16');

	newmis.velocity = vec * 1500;
	newmis.angles = vectoangles(newmis.velocity);
	newmis.oldorigin = newmis.velocity;

	newmis.nextthink = time + 1.5;
	newmis.heat = time + 1.5;

	newmis.think = SUB_Remove;
	newmis.touch = LaserBolt_Touch;
};

//=========================================================================
// Ammo/Weapon exploded by the EMP grenade
void() EMPExplode =
{
	local float expsize;

	expsize = 10;
	// Weapon?
	if (self.touch == weapon_touch)
		expsize = 60;
	else if (self.classname == "item_shells")
		expsize = 50 + self.aflag;
	else if (self.classname == "item_spikes")
		expsize = 40;
	else if (self.classname == "item_rockets")
		expsize = 100 + (self.aflag * 4);
	else if (self.classname == "item_cells")
		expsize = 100 + (self.aflag * 3);
	else if (self.classname == "item_weapon")
		expsize = 60;
	else
	{
		RPrint("EMPExplode: Attempting to explode a ");
		RPrint(self.classname);
		RPrint("\n");
		return;
	}

	deathmsg = 31;
	T_RadiusDamage (self, self.enemy, expsize, world);

	WriteByte (4, 23);
	WriteByte (4, 3);
	WriteCoord (4, self.origin_x);
	WriteCoord (4, self.origin_y);
	WriteCoord (4, self.origin_z);

	multicast (self.origin, 1);


	// Respawn
	Respawn_Item(self, self.enemy);
};

//=========================================================================
// Touch Function for EMP Grenade
void() EMPGrenadeTouch =
{
	// If the EMP Grenade hits a player, it just bounces off
	sound (self, 1, "weapons/bounce.wav", 1, 1);
	if (self.velocity == '0 0 0')
		self.avelocity = '0 0 0';
};

//=========================================================================
// EMP Grenade explode function, for when the PRIMETIME runs out
void() EMPGrenadeExplode =
{
	local float expsize;
	local entity te, oldself;
	local float total_exp;
//CH Slice gave idea of an emp gren getting rated based on blast so i added..
	total_exp = 0;

	WriteByte (4, 23);
	WriteByte (4, 4);
	WriteCoord (4, self.origin_x);
	WriteCoord (4, self.origin_y);
	WriteCoord (4, self.origin_z);

	multicast (self.origin, 1);


	local string desc;
	desc = "grenade";

	if (self.netname == "special_mine")
		desc = "mine";

	// Find all ammo in the area
	te = findradius(self.origin, 240);
	while (te)
	{	
		if (!CanDamage(te,self)) // OfN
		{
			













































































































































				SUB_Null();
		}
		else if (te.touch == ammo_touch || te.touch == weapon_touch) // Ammo/Weapon?
		{
			// Make sure it isn't picked up in the next second
			te.solid = 0;
			te.enemy = self.owner;
			te.nextthink = time + 1 + (random() * 2);
			te.think = EMPExplode;
		}
		// Detpack?
		else if (te.think == TeamFortress_DetpackExplode)
		{
			//te.solid = #SOLID_NOT;
			te.nextthink = time + 225 * random() + 30; //WK Scramble the detpack's timer. :)
			dremove(te.oldenemy); // Countdown ent

			sprint(self.owner,2,"Your EMP ",desc," damages the detpack circuits\n");
			sprint(te.owner,2,"Your detpack circuits have been damaged!\n");
		}
		// Pipebomb?
		else if (te.classname == "pipebomb")
		{
			te.nextthink = time + 0.1 + random();
		}
		// Mine?
		else if (te.classname == "grenade" && te.netname == "land_mine")
		{
			te.think = GuerillaExplode;
			te.nextthink = time + 0.1;
		}
		// Building?
		else if (IsBuilding(te)) {
			total_exp = total_exp + 120;
			TF_T_Damage(te,self,self.owner, 120, 0, 0);
		}
		// Ammobox?
		else if (te.classname == "ammobox")
		{
			expsize = 0;
			expsize = expsize + (te.ammo_shells * 0.75);
			expsize = expsize + ((te.ammo_rockets * 0.75) * 2);
			expsize = expsize + ((te.ammo_cells * 0.75) * 2);

			if (expsize > 0)
			{
				te.solid = 0;
				
				// Damage player and explode
				deathmsg = 30;
				total_exp = total_exp + expsize;
				if (expsize > 300) //CH so they are not too powerfull //WK was 500
					expsize = 300;
				T_RadiusDamage (te, self.owner, expsize, te);

				te.think = SUB_Remove;
				te.nextthink = time + 0.1;

				WriteByte (4, 23);
				WriteByte (4, 3);
				WriteCoord (4, te.origin_x);
				WriteCoord (4, te.origin_y);
				WriteCoord (4, te.origin_z);
			
				multicast (te.origin, 1);
			
			}
		}
		// Backpack/Player?

		else if ((te.classname == "player" && te.health > 0) || (te.classname=="monster_army") || (te.classname=="monster_gremlin") || (te.touch == BackpackTouch) || COOP_IsCoopMonster( te ))



		{
			expsize = 0;
			// calculate explosion size
			expsize = expsize + (te.ammo_shells * 0.75);
			expsize = expsize + ((te.ammo_rockets * 0.75) * 2);
			if (!(te.weapons_carried & 8 || te.touch == BackpackTouch))
				expsize = expsize + (te.ammo_cells * 0.75);

			if (expsize > 0)
			{
				// Damage player and explode
				deathmsg = 30;
				total_exp = total_exp + expsize;
				//WK Make players not explode radially!
				if (te.touch == BackpackTouch) 
					T_RadiusDamage (te, self.owner, expsize / 2, te); //WK Dampen backpack damage
				if (te.touch != BackpackTouch)
				{
					TF_T_Damage (te, self, self.owner, expsize, 0, 4);

					// Remove ammo
					te.ammo_shells = ceil(te.ammo_shells * 0.25);
					te.ammo_rockets = ceil(te.ammo_rockets * 0.25);
					if (!(te.cutf_items & 16 || te.tf_items & 32768))
						te.ammo_cells = ceil(te.ammo_cells * 0.25);

					if (te.classname=="player")
					{
						// Update console
						oldself = self;
						self = te;
						W_SetCurrentAmmo();
						self = oldself;
						
						WriteByte (4, 23);
						WriteByte (4, 3);
						WriteCoord (4, te.origin_x);
						WriteCoord (4, te.origin_y);
						WriteCoord (4, te.origin_z);
					
						multicast (te.origin, 1);
					
					}
				}
				else
				{
					te.think = SUB_Remove;
					te.nextthink = time + 0.1;
				}

				WriteByte (4, 23);
				WriteByte (4, 3);
				WriteCoord (4, te.origin_x);
				WriteCoord (4, te.origin_y);
				WriteCoord (4, te.origin_z);
			
				multicast (te.origin, 1);
			
			}
		}

		te = te.chain;
	}

	sound (self, 1, "weapons/gren_emp.wav", 1, 1); //- OfN - cool sound! :)

if (total_exp > 0) {//CH Thanks Slice for the idea :)

	sprint(self.owner,2, "Your EMP ",desc," inflicted ");
	local string st;
	st = ftos(total_exp);
	sprint(self.owner,2, st);
	sprint(self.owner,2, " damage\n");
}








	dremove(self);



};


//=========================================================================
// Tests whether a team is allowed to build or not

float(float myteam) HasFlag =
{
	
	if ( mapname != "steal4d" )
		return 1;
	
	if (myteam == team_with_flag){	
		return 1;
		}
	return 0;	
};

//=========================================================================
// Function handling the Engineer's build impulse
void() TeamFortress_EngineerBuild =
{
	local entity te;

	// Can't build in the air
	// WK Yes you can, why not? You can do it by pulling up this menu anyway
	/*
	if (!(self.flags & #FL_ONGROUND))
	{
		CenterPrint(self, "You can't build in the air!\n\n");
		return;
	}
	*/



	if (self.is_detpacking == 1) {
		CenterPrint(self, "You can't build while detpacking\n");
		return; 	
	}

	if (self.is_feigning == 1) {
		CenterPrint(self, "You can't build while feigning\n");
		return; 	
	}

	// Pop up the menu
	if (self.is_building == 0)
	{
		// Check to see if they've got enuf metal to build anything
		if (self.ammo_cells < 55 && self.has_dispenser == 0 && self.has_sentry == 0 && self.has_tesla == 0 && self.has_camera == 0 && self.has_teleporter == 0 && self.has_sensor == 0 && self.has_fieldgen == 0)
		{
			CenterPrint(self, "You don't have enough metal to \nbuild anything.\n\n");
			return;
		}

		self.current_menu = 15;
		self.menu_count = 25;
	}
	else if (self.is_building == 1) 
	{
		sprint(self, 2, "You stop building.\n");

		self.is_building = 0;
		self.tfstate = self.tfstate - (self.tfstate & 65536);


		TeamFortress_SetSpeed(self);




		// Remove the timer
		te = find(world, netname, "build_timer");
		while (te)
		{
			if (te.owner == self)
			{
				dremove(te);
				te = world;
			}
			else
			{
				te = find(te, netname, "build_timer");
			}
		}

		self.current_weapon = self.weapon;
		W_SetCurrentAmmo();
	}
};


float(entity obj, entity builder) CheckArea =
{
/*
	local vector src, end;
	local float pos;

	// Check the origin
	pos = pointcontents(obj.origin); 
	if (pos == #CONTENT_SOLID || pos == #CONTENT_SKY) 
		return #FALSE;

	// Check the surrounding area
	src_x = obj.origin_x + obj.maxs_x + 16;
	src_y = obj.origin_y + obj.maxs_y + 16;
	src_z = obj.origin_z + obj.maxs_z + 16;  // check upwards more

	pos = pointcontents(src); 
	if (pos == #CONTENT_SOLID || pos == #CONTENT_SKY) 
		return #FALSE;

	end_x = obj.origin_x + obj.mins_x - 16;
	end_y = obj.origin_y + obj.mins_y - 16;
	end_z = obj.origin_z + obj.mins_z - 16;
	traceline (src, end, #TL_BSP_ONLY, obj);
	if (trace_fraction != 1)
		return #FALSE;

	pos = pointcontents(end); 
	if (pos == #CONTENT_SOLID || pos == #CONTENT_SKY) 
		return #FALSE;

	// extend the size a little
	src_x = obj.origin_x + obj.mins_x - 16;
	src_y = obj.origin_y + obj.maxs_y + 16;
	src_z = obj.origin_z + obj.maxs_z + 16;

	pos = pointcontents(src); 
	if (pos == #CONTENT_SOLID || pos == #CONTENT_SKY) 
		return #FALSE;

	end_x = obj.origin_x + obj.maxs_x + 16;
	end_y = obj.origin_y + obj.mins_y - 16;
	end_z = obj.origin_z + obj.mins_z - 16; 	// check downwards less

	traceline (src, end, #TL_BSP_ONLY, obj);

	if (trace_fraction != 1)
		return #FALSE;

	pos = pointcontents(end); 
	if (pos == #CONTENT_SOLID || pos == #CONTENT_SKY) 
		return #FALSE;
*/

	if (InSolid(obj))
		return 0;

	// Trace a line from the player to the object too
	traceline(builder.origin, obj.origin, 1, builder);

	if (trace_fraction != 1)
		return 0;

	// may add in more checks later

	return 1;
};

//////////////////////////////////////////////////////////////////////////
// rehashed version of TF_Build 
void(float objtobuild, float devicenum) TeamFortress_Build =
{
	// OfN - the following is needed because we can build via menus or by cmnd
	if (self.is_building == 1)
	{
		sprint(self, 2, "You are already building something!\n");
		return;
	}
	if (intermission_running || ceasefire)
		return;
	if (self.flags & 8192)
		return;
	if (self.health <= 0 || self.deadflag != 0)
		return;
	if (prematch >= time)
		return;
	if (self.done_custom & 4) // no ppl customizing
		return;
	if (self.playerclass == 0) // no observers
		return;
	if (self.penance_time >= time) // Don't let lame teamkillers build anything
		return;

	if (!EnoughToBuild(self,objtobuild))
	{
		sprint(self, 2, "You don't have enough metal to build that!\n");
		return;
	}

	// OfN - Psionized guys can't build
	if (self.tfstate & 1048576)
	{
		sprint(self, 2, "You are not able to build while psionized!\n");
		return;
	}

	//WK Cheat Fix
	if (self.is_feigning) {
			sprint(self, 2, "Try standing up first!\n");
			return;
	}

	//OfN - Cheat Fix, heh
	if (self.is_haxxxoring) {
			sprint(self, 2, "You can't build while hacking!\n");
			return;
	}

	if (self.is_detpacking || self.is_toffingadet)
	{
		sprint (self, 2, "You can't build while manipulating a detpack!\n");
		return;
	}

	local float btime;
	//local entity te;
	local vector tmp1, tmp2;

	newmis = spawn();

	// get an origin
	makevectors(self.v_angle);
	v_forward_z = 0;
	v_forward = normalize(v_forward) * 64;
	
	if (objtobuild == 6) //- OfN - Field generators must be lined up to work
		newmis.origin = WhereGen(self.origin + v_forward);
	else
		newmis.origin = self.origin + v_forward;

	if (objtobuild == 1)
	{
		if (self.has_dispenser)
		{
			sprint(self, 2, "You can only have one dispenser.\nTry dismantling your old one.\n");
			dremove(newmis);
			return;
		}
		if (!(self.cutf_items & 1024))
		{
			sprint(self, 2, "You must buy the dispenser before you can build it.\n");
			dremove(newmis);
			return;
		}
		// Gizmo - removed the dispenser jump crap
		tmp1 = '-8 -8 0';
		tmp2 = '8 8 24';
//		tmp1 = '-16 -16 0';
//		tmp2 = '16 16 48';

		newmis.mdl = "progs/disp.mdl";		  
		
		newmis.netname = "dispenser";

		btime = time + 2;
	}
	else if (objtobuild == 2)
	{
		if (!(self.cutf_items & 16))
		{
			sprint(self, 2, "You must buy a sentry gun before you can build one.\n");
			dremove(newmis);
			return;
		}
		
		if (self.cutf_items & 4194304)
		{
			if (self.has_sentry & devicenum)
			{
				sprint(self, 2, "You already have that sentry gun up!\n");
				dremove(newmis);
				return; 			   
			}
		}
		else
		{
			if (self.has_sentry)
			{
				sprint(self, 2, "You can only have one sentry gun.\nTry dismantling your old one.\n");
				dremove(newmis);
				return;
			}
		}			 

		newmis.dont_do_triggerwork = devicenum;

		tmp1 = '-16 -16 0';
		tmp2 = '16 16 48';
		//newmis.mdl = "progs/turrbase.mdl"; 
		newmis.mdl = "progs/trrbs2.mdl";
		newmis.netname = "sentrygun";
	
		btime = time + 5;
	}
	else if (objtobuild == 3)
	{
		if (!(self.tf_items & 32768))
		{
			sprint(self, 2, "You must buy a tesla sentry before you can build one.\n");
			dremove(newmis);
			return;
		}
		
		if (self.tf_items & 4194304)
		{
			if (self.has_tesla & devicenum)
			{
				sprint(self, 2, "You already have that tesla coil up!\n");
				dremove(newmis);
				return;
			}
		}
		else
		{
			if (self.has_tesla)
			{
				sprint(self, 2, "You can only have one tesla gun.\nTry dismantling your old one.\n");
				dremove(newmis);
				return;
			}
		}

		newmis.dont_do_triggerwork = devicenum;
		
		//tmp1 = '-16 -16 0'; //- OfN commented by
		tmp1 = '-16 -16 -25';
		//tmp2 = '16 16 48'; //WK 62 is better, but crashes?
		tmp2 = '16 16 23';
		//newmis.mdl = "progs/newtesla.mdl";
		newmis.mdl = "progs/coil.mdl";
		newmis.netname = "tesla";
		newmis.origin = newmis.origin + '0 0 25';
		
	
		btime = time + 6;
	}
	else if (objtobuild == 4)
	{
		dremove(newmis);

		if (self.has_camera)
		{
			sprint(self, 2, "You can only have one security camera.\nTry dismantling your old one.\n");
			return;
		}
		if (!(self.tf_items & 65536))
		{
			sprint(self, 2, "You must buy a security camera before you can build one.\n");
			return;
		}
		
		Security_Camera_Spawn();
		return;
	}
	else if (objtobuild == 5)
	{
		if (self.has_teleporter >= 2)
		{
			sprint(self, 2, "You can only have 2 teleporters.\nTry dismantling an old one.\n");
			dremove(newmis);
			return;
		}
		if (!(self.tf_items & 131072))
		{
			sprint(self, 2, "You must buy a teleporter before you can build one.\n");
			dremove(newmis);
			return;
		}

		tmp1 = '-16 -16 0';
		tmp2 = '16 16 4';
		newmis.mdl = "progs/telepad.mdl";
		newmis.netname = "teleporter";
	
		btime = time + 3;
	}
	else if (objtobuild == 6)
	{
		if (self.has_fieldgen >= 2)
		{
			sprint(self, 2, "You already have 2 field generators.\nTry dismantling an old one.\n");
			dremove(newmis);
			return;
		}
		if (!(self.cutf_items & 524288))
		{
			sprint(self, 2, "You must buy a field generator before you can build one.\n");
			dremove(newmis);
			return;
		}

		tmp1 = '-6 -6 0';
		tmp2 = '6 6 54';
		newmis.mdl = "progs/ffgen2.mdl";
		newmis.netname = "field generator";
	
		btime = time + 4;
	} else {
		error ("TeamFortress_Build: unknown object to build");

		// Gizmo - just to get rid of qfcc warnings
		btime = 0;
		tmp1 = tmp2 = '0 0 0';
	}

	// before we start building it, check it out
	// check for validity of point
	setmodel (newmis, newmis.mdl);
	setsize (newmis, tmp1, tmp2);
	setorigin (newmis, newmis.origin);
	if (CheckArea(newmis, self) == 0)
	{
		sprint(self, 2, "Not enough room to build here\n");
		dremove(newmis);
		return;
	}

	self.is_building = 1;
	makeImmune(self,time + 2);
	//self.immune_to_check = time + 2;
	self.tfstate = self.tfstate | 65536;

	// Save the current weapon and remove it
	self.weapon = self.current_weapon;
	self.current_weapon = 0;
	self.weaponmodel = "";
	self.weaponframe = 0;


	TeamFortress_SetSpeed(self);




	newmis.owner = self;
	newmis.classname = "timer";
	newmis.netname = "build_timer";
	newmis.nextthink = btime;
	newmis.think = TeamFortress_FinishedBuilding;
	newmis.colormap = self.colormap;
	newmis.weapon = objtobuild;
	newmis.angles_y = anglemod(self.angles_y + 180);

	newmis.velocity = '0 0 8';
	newmis.movetype = 6;	 

	newmis.solid = 2;

	if (objtobuild==3)
	{
		newmis.skin = self.team_no;
		if (self.team_no==3) newmis.skin=0;
		else if (self.team_no==4) newmis.skin=3;
	}

	newmis.flags = newmis.flags - (newmis.flags & 512);
};

void() DispenserThink =
{
	local float iI; // is Improved?

	iI=1;
	
	if (self.all_active & 1)
		iI=2;


	// dispenser refilling itself 5%
	if (!(self.is_malfunctioning & 4)) // SB
	{
		self.ammo_shells = self.ammo_shells + rint((400*iI) / 10);
		self.ammo_cells = self.ammo_cells + rint((650*iI) / 10);
		self.ammo_nails = self.ammo_nails + rint((600*iI) / 10);
		self.ammo_rockets = self.ammo_rockets + rint((300*iI) / 10);
		self.armorvalue = self.armorvalue + rint((500*iI) / 10); 

		if (self.ammo_shells > 400*iI)
			self.ammo_shells = 400*iI;	
		if (self.ammo_nails > 600*iI)
			self.ammo_nails = 600*iI;	
		if (self.ammo_rockets > 300*iI)
			self.ammo_rockets = 300*iI;	
		if (self.ammo_cells > 650*iI)
			self.ammo_cells = 650*iI;	
		if (self.armorvalue > 500*iI)
			self.armorvalue = 500*iI;
			
		if (self.all_active & 8) // Upgraded dispenser
		{
			self.ammo_detpack = self.ammo_detpack + (2*iI) /10;
			self.ammo_c4det = self.ammo_c4det + (2*iI) /10;
			self.ammo_medikit = self.ammo_medikit + rint((250*iI) /10);

			if (self.ammo_detpack > 2*iI)
				self.ammo_detpack = 2*iI;	
			if (self.ammo_c4det > 2*iI)
				self.ammo_c4det = 2*iI;
			if (self.ammo_medikit > 250*iI)
				self.ammo_medikit = 250*iI;
		}
	}
	self.nextthink = time + 10;
};

void() TeamFortress_FinishedBuilding =
{
	local entity oldself;
//	local float current_yaw;
//	local vector source;

	if (self.owner.is_building != 1)
		return;

	oldself = self;
	self = self.owner;
	oldself.owner = world;
	oldself.real_owner = self;

	self.is_building = 0;
	self.tfstate = self.tfstate - (self.tfstate & 65536);
	self.current_weapon = self.weapon;
	self.StatusRefreshTime = time + 0.1;

	TeamFortress_SetSpeed(self);

	if (oldself.weapon == 1)
	{
		self.has_dispenser = 1;
		sprint (self, 2, "You finish building the dispenser.\n");

		teamprefixsprint(self.team_no,self); //- OfN

		teamsprint(self.team_no, self, self.netname);
		teamsprint(self.team_no, self, " has built a Dispenser.\n");

		self.ammo_cells = self.ammo_cells - 100;
		
		// Create the dispenser
		oldself.classname = "building_dispenser";
		oldself.netname = "dispenser";
		oldself.blocked = T_Dispenser;		// Actual touch function
		oldself.touch = T_Dispenser;
		oldself.max_health = 150;
		oldself.health = 150;
		oldself.think = DispenserThink;
		oldself.nextthink = time + 5;
		oldself.th_die = Dispenser_Die; 	// Death function
		
		oldself.mdl = "progs/disp.mdl"; 	// Actual mdl
		
		oldself.team_no = self.team_no;

		oldself.all_active=0; // OfN - reset HACKER improvements
		oldself.is_malfunctioning = 0;

		oldself.real_owner = self;			// The Engineer owns this item
		oldself.colormap = self.colormap;	// Set the Color
		oldself.takedamage = 2;
		oldself.owner = world;
		oldself.movetype = 6;
		oldself.velocity = '0 0 8';
		oldself.flags = oldself.flags - (oldself.flags & 512);

		// Put some ammo in the Dispenser
		oldself.ammo_shells = ceil(self.ammo_shells * 0.25);
		oldself.ammo_nails = ceil(self.ammo_nails * 0.25);
		oldself.ammo_rockets = ceil(self.ammo_rockets * 0.25);
		oldself.ammo_cells = ceil(self.ammo_cells * 0.25);
		oldself.armorvalue = ceil(self.armorvalue * 0.25);
		
		oldself.ammo_medikit = ceil(self.ammo_medikit * 0.25);

		oldself.ammo_detpack = ceil(self.ammo_detpack * 0.25);
		oldself.ammo_c4det = ceil(self.ammo_c4det * 0.25);
		
		// Remove ours
		self.ammo_shells = ceil(self.ammo_shells * 0.75);
		self.ammo_nails = ceil(self.ammo_nails * 0.75);
		self.ammo_rockets = ceil(self.ammo_rockets * 0.75);
		self.ammo_cells = ceil(self.ammo_cells * 0.75);
		self.armorvalue = ceil(self.armorvalue * 0.75);

		self.ammo_detpack = ceil(self.ammo_detpack * 0.75);
		self.ammo_c4det = ceil(self.ammo_c4det * 0.75);
		
		self.ammo_medikit = ceil(self.ammo_medikit * 0.75);

		oldself.solid = 2;
		setmodel(oldself, oldself.mdl);
//		setsize (oldself, '-8 -8 0', '8 8 24');
	}
	else if (oldself.weapon == 2)
	{
		//CH special sbar for eng.
		self.StatusBarScreen = 1;
		//self.has_sentry = #TRUE;
		self.has_sentry = self.has_sentry | oldself.dont_do_triggerwork;
		sprint (self, 2, "You finish building the sentry gun.\n");

		teamprefixsprint(self.team_no,self); //- OfN

		teamsprint(self.team_no, self, self.netname);
		teamsprint(self.team_no, self, " has built a Sentry Gun.\n");
			
		oldself.classname = "building_sentrygun_base";
		oldself.netname = "sentry gun";
		oldself.takedamage = 0;
		oldself.th_die = Sentry_Die;		// Death function
		self.ammo_cells = self.ammo_cells - 130;

		setsize (oldself, '-16 -16 0', '16 16 4'); // '-16 -16 0' '16 16 4'
		newmis = spawn();
		newmis.dont_do_triggerwork = oldself.dont_do_triggerwork;
		newmis.classname = "building_sentrygun";
		newmis.health = 150;
		newmis.max_health = newmis.health;
		newmis.tf_items = 4; //Start with kevlar armor
		newmis.armorclass = 1; //kevlar armor
		newmis.weapon = 1;					// Level 1 Turret
		newmis.th_die = Sentry_Die; 		// Death function
		newmis.th_pain = Sentry_Pain;
		//newmis.mdl = "progs/turrgun.mdl";
		newmis.mdl = "progs/trrgn2.mdl";
		sound (oldself, 3, "weapons/turrset.wav", 1, 1);
		newmis.solid = 2;
		setmodel(newmis, newmis.mdl);
		setsize (newmis, '-16 -16 0', '16 16 48'); 
		setorigin(newmis, oldself.origin + '0 0 8'); 
		newmis.real_owner = oldself.real_owner; // The Engineer owns this item
		newmis.trigger_field = oldself;
		oldself.oldenemy = newmis;
		newmis.movetype = 4;
		oldself.colormap = self.colormap;	// Set the Base Color
		newmis.colormap = self.colormap;	// Set the Color

		newmis.skin = self.team_no - 1;

		newmis.takedamage = 2;
		newmis.velocity = '0 0 -8';
		newmis.flags = newmis.flags - (newmis.flags & 512);
		oldself.flags = oldself.flags - (oldself.flags & 512);

		newmis.frags = 0; //CH how many people has your sent killed?

		newmis.team_no = self.team_no;
		newmis.think = lvl1_sentry_stand;
		newmis.nextthink = time + 0.5;
		newmis.touch = Sentry_Touch;
		// Rotate Details
		newmis.yaw_speed = 10;	//Turn rate
		newmis.heat = 0;	// Turn Right
		newmis.angles_x = 0;
		newmis.angles_y = ceil(oldself.angles_y); //CH remove decimal
		newmis.angles_z = 0;

		newmis.angles_y = ((ceil(newmis.angles_y / 10)) * 10); //CH set last int to 0
		
		
		newmis.waitmin = newmis.angles_y - 50; // removed anglemod
		newmis.waitmax = newmis.angles_y + 50;
		




		// Give the Gun some ammo
		newmis.ammo_shells = 75; //WK
		newmis.maxammo_shells = 100;
		newmis.maxammo_rockets = 20;

		newmis.all_active=0; // OfN - reset HACKER improvements
		newmis.is_malfunctioning = 0;
		newmis.attack_finished=time; //- controls time after loosing track of enemy to not be rotating
		newmis.has_holo=0;

		newmis.has_fieldgen = time; // resets invulnerability of attacking holos 'sindrome'

	}
	else if (oldself.weapon == 3)
	{
		//CH special sbar for eng.
		self.StatusBarScreen = 4;
		//self.has_tesla = #TRUE;
		self.has_tesla = self.has_tesla | oldself.dont_do_triggerwork;
		sprint (self, 2, "You finish building the tesla.\n");

		teamprefixsprint(self.team_no,self); //- OfN
		
		teamsprint(self.team_no, self, self.netname);
		teamsprint(self.team_no, self, " has built a tesla.\n");
		sound (oldself, 3, "weapons/guerset.wav", 1, 1);
			
		oldself.classname = "building_tesla";
		oldself.netname = "tesla";
		oldself.takedamage = 2;
		oldself.solid = 2;
		oldself.th_die = Tesla_Die; 		// Death function
		oldself.th_pain = Tesla_Pain;
		self.ammo_cells = self.ammo_cells - 100;

		oldself.health = 150;
		oldself.movetype = 6;
		oldself.colormap = self.colormap;	// Set the Base Color
		oldself.velocity = '0 0 -8';
		oldself.avelocity = '0 0 0';
		oldself.flags = oldself.flags - (oldself.flags & 512);
		oldself.team_no = self.team_no;
		
		//- OfN -
		//oldself.think = Tesla_Idle;
		oldself.think = tsla_on1;
		//oldself.nextthink = time + 2;
		oldself.nextthink = time + 0.1;
		oldself.has_holo = time + 2; // next Tesla_Idle run
		oldself.job = 0; // this flag will determine which frame animation is currently on
		//oldself.job_finished = time; // change for frame animation purposes, instead of increasing its nextthing during charging
		oldself.no_grenades_1 = 0; // first think reset
		oldself.no_grenades_2 = 0; // cloak touch delay reset

		oldself.touch = Tesla_Touch;
		oldself.enemy = world;
		oldself.oldenemy = world; //CH for sbar

		//Set all initial tesla values here
		oldself.maxammo_shells = 0; //Voltage == 0
		oldself.maxammo_nails = 0; //Amps == 0
		oldself.maxammo_rockets = 0; //Battery == 0
		oldself.max_health = oldself.health;
		oldself.ammo_cells = 50; //Initial ammo allocation
		oldself.maxammo_cells = 50; //Initial maxammo
		oldself.tf_items = 32; //Start with shock armor
		oldself.armorclass = 8; //Shock armor
		if (self.tf_items & 262144) {
			oldself.has_sentry = 6; //Normal Upgrades
			oldself.has_tesla = 2; //Misc Upgrade
		}
		else
		{
			oldself.has_sentry = 4; //Normal Upgrades
			oldself.has_tesla = 1; //Misc Upgrade
		}
		oldself.has_teleporter = 0; //CH for frag related upgrades
		if (!(self.weapons_carried & 8)) { //No spanner























			oldself.ammo_shells = 1;
			oldself.ammo_nails = 2;
			oldself.ammo_rockets = 1;
			oldself.has_sentry = oldself.has_sentry - 4; //Take away 3
			oldself.max_health = 225;
			oldself.ammo_cells = 120; //Initial ammo allocation
			oldself.maxammo_cells = 120;

		}
		oldself.health = oldself.max_health;
		oldself.waitmin = (oldself.ammo_shells + 2) * (oldself.ammo_nails + 2);
		oldself.waitmax = 0; //No target yet

		oldself.frags = 0; //CH how many people has your sent killed?
		oldself.lip   = 0; //WK How many tinkers have been done
		modelindex_tesla = oldself.modelindex; //CH

		oldself.all_active=0; // OfN - reset HACKER improvements
		oldself.is_malfunctioning = 0;
		oldself.has_fieldgen = time;
		oldself.is_haxxxoring=0; // isnt flying
	}
	else if (oldself.weapon == 5)
	{
		self.has_teleporter = (self.has_teleporter + 1);
		sprint (self, 2, "You finish building the Teleporter Pad.\n");

		teamprefixsprint(self.team_no,self); //- OfN

		teamsprint(self.team_no, self, self.netname);
		teamsprint(self.team_no, self, " has built a Teleporter Pad.\n");
		sound (oldself, 3, "weapons/guerset.wav", 1, 1);

		self.ammo_cells = self.ammo_cells - 90;

		// Create the teleporter
		oldself.classname = "building_teleporter";
		oldself.netname = "teleporter";
//		oldself.blocked = Teleporter_touch; 	// Actual touch function
		oldself.touch = Teleporter_touch;
		oldself.max_health = 300;
		oldself.health = 300;
		oldself.th_die = Teleporter_Die;		// Death function
		oldself.mdl = "progs/telepad.mdl";		// Actual mdl
		oldself.team_no = self.team_no;
		oldself.maxammo_cells = 200;	//CH Max of 20 teleports
		oldself.ammo_cells = 100;	//CH start not at full

		oldself.real_owner = self;			// The Engineer owns this item
		oldself.colormap = self.colormap;	// Set the Color
		oldself.takedamage = 2;
		oldself.owner = world;
		oldself.movetype = 6;
		oldself.velocity = '0 0 8';
		oldself.flags = oldself.flags - (oldself.flags & 512);

		oldself.solid = 2;
		setmodel(oldself, oldself.mdl);
//		setsize (oldself, '-16 -16 0', '16 16 4');

		oldself.heat = 4; //dont come on for 4 seconds
		oldself.think = Teleporter_heat_think;
		oldself.nextthink = time + 1;
		oldself.spawnflags = 4; //CH cause extensive checks for height

		oldself.is_malfunctioning = 0;
		oldself.all_active=0; // OfN - reset HACKER improvements
	}
	else if (oldself.weapon == 6)
	{
		self.has_fieldgen = (self.has_fieldgen + 1);
		sprint (self, 2, "You finish building the Field Generator.\n");

		teamprefixsprint(self.team_no,self); //- OfN

		teamsprint(self.team_no, self, self.netname);
		teamsprint(self.team_no, self, " has built a Field Generator.\n");
		sound (oldself, 3, "weapons/guerset.wav", 1, 1);

		self.ammo_cells = self.ammo_cells - 120;

		// Create the field generator
		oldself.classname = "building_fieldgen";
		oldself.netname = "field generator";
//		oldself.blocked = Teleporter_touch; 	// Actual touch function
		//oldself.touch = Teleporter_touch;
		oldself.max_health = 300;
		oldself.health = 300;
		oldself.th_die = FieldGen_Die;		// Death function
		oldself.mdl = "progs/ffgen2.mdl";		// Actual mdl
		oldself.team_no = self.team_no;
		
		oldself.maxammo_cells = 150; //CH Max of 20 field recharges
		oldself.ammo_cells = 150 / 2;	//CH start not at full*/

		oldself.real_owner = self;			// The Engineer owns this item
		oldself.colormap = self.colormap;	// Set the Color
		oldself.takedamage = 2;
		oldself.owner = world;
		oldself.movetype = 6;
		oldself.velocity = '0 0 8';
		oldself.flags = oldself.flags - (oldself.flags & 512);

		oldself.solid = 2;

		oldself.angles = '0 0 0';

		setmodel(oldself, oldself.mdl);
//		setsize (oldself, '-6 -6 0', '6 6 54');


		//oldself.heat = 4; //dont come on for 4 seconds
		/*oldself.think = Teleporter_heat_think;
		oldself.nextthink = time + 1;*/

		oldself.spawnflags = 4; //CH cause extensive checks for height

		oldself.is_malfunctioning = 0;
		oldself.all_active=0; // OfN - reset HACKER improvements

		FieldGen_Built(oldself);
	}

	// Add string flags used for earthquake and storm find()'s
	if (oldself.weapon == 2)
		UpdateVulnerability(newmis);
	else
		UpdateVulnerability(oldself);		 
	
	if (self.ammo_cells < 0)
		self.ammo_cells = 0;

	W_SetCurrentAmmo();
};

//=========================================================================
// Dispenser Touch function. Allows players to get stuff from the Dispenser.

void() T_Dispenser =
{
	local entity dist_checker;

	if (other.classname != "player")
		return;
		
	if (self.is_malfunctioning & 1)
		return;
		
	if (self.is_malfunctioning & 2)
		TF_T_Damage(self, self, self, 200, 0, 0);

	// Ignore any engineer working on this dispenser
	if (other.building == world && other.building_wait < time)
	{
		// Pop up the menu
		other.current_menu = 20;
		other.menu_count = 25;

		other.building = self;

		// Start a Distance checker, which removes the menu if the player
		// gets too far away from the Dispenser.
		dist_checker = spawn();
		dist_checker.classname = "timer";
		dist_checker.owner = other;
		dist_checker.enemy = self;
		dist_checker.think = CheckDistance;
		dist_checker.nextthink = time + 0.3;
	}
};

//============================================================
// this is needed to avoid stack overflow

void() Dispenser_Explode =
{	 
	T_RadiusDamage(self.demon_one, self.demon_one, self.has_holo, world);

	local entity sprite;

	sprite = SpawnSprite(1,2,self.demon_one.origin,'0 0 0',2,0.1);

	if (sprite)
	{
		sprite.effects = 8;

		if (self.demon_one.real_owner.team_no == 1)
			sprite.effects = 8 | 64;
		else if (self.demon_one.real_owner.team_no == 2)
			sprite.effects = 8 | 128;
	}

	WriteByte (4, 23);
	WriteByte (4, 3);
	WriteCoord (4, self.demon_one.origin_x);
	WriteCoord (4, self.demon_one.origin_y);
	WriteCoord (4, self.demon_one.origin_z);

	multicast (self.demon_one.origin, 1);
	dremove(self.demon_one);




	dremove(self); // remove explosion timer for this dispenser
};

void() Dispenser_Die =
{
	local float damg;
	self.real_owner.has_dispenser = 0;
	
	damg = self.ammo_cells * 0.25;
	damg = damg + self.ammo_nails * 0.1;
	damg = damg + self.ammo_shells * 0.2;
	damg = damg + self.ammo_rockets / 2;
	
	//- OfN causes overflow so we need a timer for dispenser explosion
	newmis = spawn();
	newmis.has_holo = damg;
	newmis.demon_one = self;
	newmis.nextthink = time + 0.1;
	newmis.think = Dispenser_Explode;
	/*T_RadiusDamage(self, self, damg, world); // OfN - Fixme, stack overflow??*/


	sprint(self.real_owner, 2, "Your dispenser was destroyed.\n");

	ThrowGib("progs/dgib1.mdl", -30, 1, 0, 0, 0);
	ThrowGib("progs/dgib2.mdl", -50, 1, 0, 0, 0);
	ThrowGib("progs/dgib3.mdl", -50, 1, 0, 0, 0);
};

//=========================================================================
// Engineer has used a Spanner on the Dispenser
void(entity disp) Engineer_UseDispenser =
{
	local entity dist_checker;
	local string st;

	// Print the dispenser's details
	sprint (self, 2, "Dispenser has ");
	st = ftos(disp.health);
	sprint(self, 2, st);
	sprint(self, 2, "¯");
	st = ftos(disp.max_health);
	sprint(self, 2, st);
	sprint (self, 2, " èåáìôè\n");
	st = ftos(disp.ammo_shells);
	sprint (self, 2, st);
	sprint (self, 2, " óèåììó, ");
	st = ftos(disp.ammo_nails);
	sprint (self, 2, st);
	sprint (self, 2, " îáéìó, ");
	st = ftos(disp.ammo_rockets);
	sprint (self, 2, st);
	sprint (self, 2, " òïãëåôó\n");
	st = ftos(disp.ammo_cells);
	sprint (self, 2, st);
	sprint (self, 2, " ãåììó, and ");
	st = ftos(disp.armorvalue);
	sprint (self, 2, st);
	sprint (self, 2, " áòíïò\n");

	if (disp.all_active & 8)
	{
		st = ftos(disp.ammo_medikit);
		sprint (self, 2, st);
		

		local float f;
		f = 1;

		if (disp.all_active & 1)
			f = 2;
		
		sprint (self, 2, "¯");

		st = ftos(250 * f);
		sprint (self, 2, st);
		sprint (self, 2, " Íåäéëéô\n");
				
		st = ftos(floor(disp.ammo_detpack));
		sprint (self, 2, st);
		sprint (self, 2, " Äåôðáãëó ");

		st = ftos(floor(disp.ammo_c4det));
		sprint (self, 2, st);
		sprint (self, 2, " Ã– Äåôðáãëó\n");
	}

	// Pop up the menu
	self.current_menu = 16;
	self.menu_count = 25;

	self.building = disp;

	// Start a Distance checker, which removes the menu if the player
	// gets too far away from the Dispenser.
	dist_checker = spawn();
	dist_checker.classname = "timer";
	dist_checker.owner = self;
	dist_checker.enemy = disp;
	dist_checker.think = CheckDistance;
	dist_checker.nextthink = time + 0.3;
};

//=========================================================================
// Engineer has used a Spanner on the SentryGun
void(entity gun) Engineer_UseSentryGun =
{
	local entity dist_checker;
	local string st;

	// Print the gun's details
	sprint(self, 2, "Ìåöåì ");
	st = Return_Colored_Num(gun.weapon);
	sprint(self, 2, st);
	sprint(self, 2, " Sentry Gun has ");
	st = ftos(gun.health);
	sprint(self, 2, st);
	sprint(self, 2, "¯");
	st = ftos(gun.max_health);
	sprint(self, 2, st);
	sprint(self, 2, " èåáìôè, ");
	st = ftos(gun.ammo_shells);
	sprint(self, 2, st);
	sprint(self, 2, " óèåììó");
	if (gun.weapon == 3)
	{
		st = ftos(gun.ammo_rockets);
		sprint(self, 2, ", ");
		sprint(self, 2, st);
		sprint(self, 2, " òïãëåôó");
	}
	sprint(self, 2, "\n");

	sprint(self, 2, "Sentry Gun ÆÒÁÇÓ: "); //CH Displays kills of sent
		st = ftos(gun.frags);
	sprint(self, 2, st);
	sprint(self, 2, "\n");

	// Pop up the menu
	self.current_menu = 17;
	self.menu_count = 25;

	self.building = gun;

	//dodgy
	if (teamplay != 0 && !Teammate(self.building.real_owner.team_no,self.team_no)) {
		Menu_EngineerFix_SentryGun_Input(5);
		return;
	}

	// - OfN - Adds 4-6 seconds of smart sentry gun targetting (no holos)
	gun.has_fieldgen = time + 4 + 2*random();
	
	if (gun.enemy.classname=="holo" && gun.enemy.has_holo == 1)
		sprint(self, 2,"You adjust the sentry gun to ignore the holo\n");
	
	// Start a Distance checker, which removes the menu if the player
	// gets too far away from the sentry.
	dist_checker = spawn();
	dist_checker.classname = "timer";
	dist_checker.owner = self;
	dist_checker.enemy = gun;
	dist_checker.think = CheckDistance;
	dist_checker.nextthink = time + 0.3;
};

////////////////////////////////////////////////
// Engineer has used a Spanner on the Tesla
void(entity gun) Engineer_UseTesla =
{
	local entity dist_checker;
	local string st;

	// Print the gun's details
	sprint(self, 2, "Èåáìôè:");
	st = ftos(gun.health);
	sprint(self, 2, st);
	sprint(self, 2, "¯");
	st = ftos(gun.max_health);
	sprint(self, 2, st);
	sprint(self, 2, " Ãåììó:");
	st = ftos(gun.ammo_cells);
	sprint(self, 2, st);
	sprint(self, 2, "¯");
	st = ftos(gun.maxammo_cells);
	sprint(self, 2, st);
	st = ftos(gun.has_sentry);
	sprint(self, 2, " Îïòíáì Ups Left:");
	sprint(self, 2, st);
	st = ftos(gun.has_tesla);
	sprint(self, 2, " Íéóã Ups Left:");
	sprint(self, 2, st);
	sprint(self, 2, "\n");

	sprint(self, 2, "Öïìôáçå:");
	st = ftos(gun.ammo_shells);
	sprint(self, 2, st);
	sprint(self, 2, " Áíðåòáçå:");
	st = ftos(gun.ammo_nails);
	sprint(self, 2, st);
	sprint(self, 2, " Ðï÷åò Óõððìù:");
	st = ftos(gun.ammo_rockets);
	sprint(self, 2, st);
	sprint(self, 2, "\n");
	if (gun.tf_items) {
		local float num;
		num = 0;
		if (gun.tf_items & 2) {
			sprint(self, 2, "TeslaTurret(tm). ");
			num = num + 1;
		}
		if (gun.tf_items & 1) {
			sprint(self, 2, "Improved Targeter. ");
			num = num + 1;
		}
		if (gun.tf_items & 1024) {
			sprint(self, 2, "Spy Detector. ");
			num = num + 1;
		}
		if (gun.tf_items & 4) {
			sprint(self, 2, "Kevlar Armor. ");
			num = num + 1;
		}
		if (gun.tf_items & 16) {
			sprint(self, 2, "Blast Armor. ");
			num = num + 1;
		}
		if (gun.tf_items & 64) {
			sprint(self, 2, "Asbestos Armor. ");
			num = num + 1;
		}
		if (gun.tf_items & 131072) {
			sprint(self, 2, "Upgrades from frags. ");
			num = num + 1;
		}
		if (gun.tf_items & 512) {
			sprint(self, 2, "Cloaking Device. ");
			num = num + 1;
		}
		if (num != 0)
			sprint(self, 2, "\n");
	}

	sprint(self, 2, "Tesla Sentry ÆÒÁÇÓ: "); //CH Displays kills of tesla
		st = ftos(gun.frags);
	sprint(self, 2, st);
	sprint(self, 2, "\n");

	// Pop up the menu
	self.current_menu = 18;
	self.menu_count = 25;

	self.building = gun;

	// dodgy
	if (teamplay != 0 && !Teammate(self.building.real_owner.team_no, self.team_no)) {
		Menu_EngineerFix_Tesla_Input(8);
		return;
	}

	// - OfN - Adds 6-9 seconds of smart tesla targetting (no holos)
	gun.has_fieldgen = time + 6 + 3*random();
		
	if (gun.enemy.classname == "holo" && gun.enemy.has_holo == 1)
	{		 
		sprint(self, 2,"You adjust the tesla sentry to ignore the holo\n");
	}

	// Start a Distance checker, which removes the menu if the player
	// gets too far away from the tesla.
	dist_checker = spawn();
	dist_checker.classname = "timer";
	dist_checker.owner = self;
	dist_checker.enemy = gun;
	dist_checker.think = CheckDistance;
	dist_checker.nextthink = time + 0.3;
};
//=================
void(entity cam) Engineer_UseSensor =
{
	local entity dist_checker;
	local string st;

	sprint(self, 2, "Motion Sensor has ");
	st = ftos(cam.health);
	sprint(self, 2, st);
	sprint(self, 2, "¯");
	st = ftos(ceil(cam.max_health));
	sprint(self, 2, st);
	sprint(self, 2, " èåáìôè\n");

	// Pop up the menu
	self.current_menu = 23;
	self.menu_count = 25;

	self.building = cam;

	if (teamplay != 0 && !Teammate(self.building.real_owner.team_no, self.team_no)) {
		Menu_EngineerFix_Sensor_Input(3);
		return;
	}

	// Start a Distance checker, which removes the menu if the player
	// gets too far away from the camera.
	dist_checker = spawn();
	dist_checker.classname = "timer";
	dist_checker.owner = self;
	dist_checker.enemy = cam;
	dist_checker.think = CheckDistance;
	dist_checker.nextthink = time + 0.3;

};
//=================
void(entity cam) Engineer_UseCamera =
{
	local entity dist_checker;
	local string st;

	sprint(self, 2, "Security Camera has ");
	st = ftos(cam.health);
	sprint(self, 2, st);
	sprint(self, 2, "¯");
	st = ftos(ceil(cam.max_health));
	sprint(self, 2, st);
	sprint(self, 2, " èåáìôè\n");

	// Pop up the menu
	self.current_menu = 21;
	self.menu_count = 25;

	self.building = cam;

	if (teamplay != 0 && !Teammate(self.building.real_owner.team_no,self.team_no)) {
		Menu_EngineerFix_Camera_Input(3);
		return;
	}

	// Start a Distance checker, which removes the menu if the player
	// gets too far away from the camera.
	dist_checker = spawn();
	dist_checker.classname = "timer";
	dist_checker.owner = self;
	dist_checker.enemy = cam;
	dist_checker.think = CheckDistance;
	dist_checker.nextthink = time + 0.3;

};
//=================
void(entity tele) Engineer_UseTeleporter =
{
	local entity dist_checker;
	local string st;

	sprint(self, 2, "Teleporter Pad has ");
	st = ftos(tele.health);
	sprint(self, 2, st);
	sprint(self, 2, "¯");
	st = ftos(ceil(tele.max_health));
	sprint(self, 2, st);
	sprint(self, 2, " èåáìôè  ");
	st = ftos(tele.ammo_cells);
	sprint(self, 2, st);
	sprint(self, 2, "¯");
	st = ftos(ceil(tele.maxammo_cells));
	sprint(self, 2, st);
	sprint(self, 2, " ãåììó\n");


	// Pop up the menu
	self.current_menu = 22;
	self.menu_count = 25;

	self.building = tele;

	if (teamplay != 0 && !Teammate(self.building.real_owner.team_no,self.team_no)) {
		Menu_EngineerFix_Teleporter_Input(8); // PZ: fixed bug; was 4
		return;
	}

	// Start a Distance checker, which removes the menu if the player
	// gets too far away from the teleporter.
	dist_checker = spawn();
	dist_checker.classname = "timer";
	dist_checker.owner = self;
	dist_checker.enemy = tele;
	dist_checker.think = CheckDistance;
	dist_checker.nextthink = time + 0.3;

};
//=========================================================================
// Think function for the timer which checks the distance between the 
// Engineer and the building he's using
void() CheckDistance =
{
	local vector dist;
	
	// Check to see if the Engineer's spanner'ed a different building 
	// without leaving the area of this one.
	if (self.owner.building != self.enemy)
	{
		dremove(self);
		return;
	}

	dist = self.enemy.origin - self.owner.origin;
//WK	if (vlen(dist) > 64)
	if (vlen(dist) > 98)
	{
		CenterPrint(self.owner, "\n");
		self.owner.menu_count = 25;
		self.owner.current_menu = 1;
		self.owner.building = world;
		dremove(self);
		return;
	}

	self.nextthink = time + 0.3;
};


