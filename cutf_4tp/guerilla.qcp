/*=======================================================//
// guerilla.QC - CustomTF 3.2.OfN		   - 18/4/2004 - //
=========================================================//
 Guerilla job stuff - Revamped by OfteN [cp]
---------------------------------------------------------//
 Moved to its own file due to the huge changes
 The Guerilla Menu is also handled here
=========================================================*/

/*
** Guerilla Profession -
** Can set self-detonating land mines
**
** OfN - Modified and improved using JOB_EXTRA's
** No job extras = Everything as before
** 1 extra = Menu, can place level2 mines and special mines
** 2 extras = Menu, can place level3 and level2 mines, special mines
**			  and can convert grenades into mines.
** Appart from converted mines when u have "Specialist":
** When having any job extras a player can place NAPALM or BIO mines
** if he has Pyrotoys or napalm grens and medikit or bio grens respectively
*/

// Guerilla maximums and job setttings







// Bonuses




//- Mine types -//

// Regular mines





// Special mines






// Converted-only mines








// Damage settings








// Flags for converted mines on player entity (2nd byte on .increase_team4 field)



// Various settings







/*===============================================================================================

EXPLANATION OF HOW THE ENTITY FIELDS ARE USED (thnx? np.. :P)
---------------------------------------------

For player entity:
------------------

.all_active 	- Used for the following stuff
				(byte1) Points spent on currently existing mines 
				(byte2) Mine points still avaliable for mines
				(byte3) Mine points earned

.increase_team4 - Used for the following stuff
	(WARNING: This field is used also for warlock/army status bar)
				(byte1) Number of mines up
				(byte2) Bitfield for converted grenade flags
					|1 Converted type1 grenade mine up
					|2 Converted type2 grenade mine up
				(byte3) UNUSED STILL
			   

.dont_do_triggerwork -
	(WARNING: This field is used also for warlock points/army rating)
				Kills achieved by mines

For mine entity:
----------------

.health 			- Remaining life time for the mine
.last_attacked_time - Controls delay between beeps on mine
.has_tesla			- Determines what to sprint to owner on mine explosion
.heat				- Time variable, determines if mine is charged
.has_sentry 		- Type of the mine
.has_sensor 		- Determines if this mine is a standard lvl1/lvl2/lvl3 mine or not
.has_fieldgen		- Flag used to flash mines on activation
.has_holo			- If 1 or 2, mine is a converted grenade, indicates grenade slot also

================================================================================================*/

float(entity player) GetMineSpentPoints;
float(entity player) GetMinePoints;
float(entity player) GetMineEarnedPoints;
void(entity player,float spentpoints) SetMineSpentPoints;
void(entity player,float points) SetMinePoints;
void(entity player,float points) SetMineEarnedPoints;

float(entity player) GetMineConvBitfield;
void(entity player, float bitfield) SetMineConvBitfield;
float(entity player) GetMinesUp;
void(entity player, float minesup) SetMinesUp;


void(float minetype, float converted) GuerillaSetMine;
string(float typ) GetGrenadeText;
float(float typ) IsMineConvertible;
string(float minetype) GetMineStr;
float(float grentype) ConvertGrenIDToMine;
void(entity player, entity mine) MineUp;
void(entity player, entity mine) MineDown;
float(entity player, float minetype, float converted) AttemptToSetMine;
float(float minetype) MineNeededPoints;
float(entity player) GuerillaGetMaxPointsForJob;
void(entity player) GuerillaUpgradeJob;
//float(entity player) GuerillaGetTotalPoints;

// External
void(entity pl, string s1, string s2, string s3, string s4, string s5, string s6, string s7) CenterPrint7;
void() ConcussionGrenadeExplode;
void() PsionicGrenadeExplode;
void() BioGrenadeExplode;
void() NapalmGrenadeExplode;
void() MirvGrenadeExplode;
void() NailGrenadeExplode;
void() GasGrenadeExplode;
void() EMPGrenadeExplode;
void() FragGrenadeExplode;
void() KracGrenadeExplode;
void() CaltropGrenadeExplode;
void() AntiGravGrenadeExplode;

float(entity player, float damage) HurtLegs;

float( entity thing ) IsOwnedMonster;
float( entity thing ) IsMonster;

//===============================================================
// Guerilla menu (only used if we have job extras)

void() Menu_Guerilla =
{
	local string header, st1, st2, st3, st4, st5, foot, tmp;
	local float extras, points, bitfield, minesup;

	extras = GetJobExtras(self);
	points = GetMinePoints(self);
	minesup = GetMinesUp(self);

	if (extras == 1) // Technician
	{
		if (!minesup)
		{
			header = "Τεγθξιγιαξ:     ¨no mines up©\n\n";
		}
		else if (minesup == 1)
		{
			header = "Τεγθξιγιαξ:      ¨1 mine up©\n\n";
		}
		else
		{
			header = "Τεγθξιγιαξ:      ¨";
			tmp = ftos(minesup);
			header = strcat(header,tmp);
			header = strcat(header," mines up©\n\n");
		}
		
		if (points <= 0)
		{
			st1 = ".. Level 1 Mine        (1 point)\n.. Level 2 Mine       (2 points)\n\n.. Concussion Mine     (1 point)\n.. Psionic Mine       (2 points)\n";
			
			if (self.tp_grenades_1 == 5 || self.tp_grenades_2 == 5 || self.weapons_carried & 4096)
				st2 = ".. Napalm Mine        (3 points)\n";
			else if (self.tp_grenades_1 == 13 || self.tp_grenades_2 == 13 || self.weapons_carried & 4)
				st2 = ".. Biological Mine    (2 points)\n";
			else
				st2 = "\n";

			st3 = ".. MIRV Mine          (3 points)\n\n";
		}
		else if (points == 1)
		{
			st1 = ".. Level 1 Mine        ( ποιξτ)\n.. Level 2 Mine       (2 points)\n\n.. Concussion Mine     ( ποιξτ)\n.. Psionic Mine       (2 points)\n";
			
			if (self.tp_grenades_1 == 5 || self.tp_grenades_2 == 5 || self.weapons_carried & 4096)
				st2 = ".. Napalm Mine        (3 points)\n";
			else if (self.tp_grenades_1 == 13 || self.tp_grenades_2 == 13 || self.weapons_carried & 4)
				st2 = ".. Biological Mine    (2 points)\n";
			else
				st2 = "\n";

			st3 = ".. MIRV Mine          (3 points)\n\n";
		}
		else if (points == 2)
		{
			st1 = ".. Level 1 Mine        ( ποιξτ)\n.. Level 2 Mine       ( ποιξτσ)\n\n.. Concussion Mine     ( ποιξτ)\n.. Psionic Mine       ( ποιξτσ)\n";
			
			if (self.tp_grenades_1 == 5 || self.tp_grenades_2 == 5 || self.weapons_carried & 4096)
				st2 = ".. Napalm Mine        (3 points)\n";
			else if (self.tp_grenades_1 == 13 || self.tp_grenades_2 == 13 || self.weapons_carried & 4)
				st2 = ".. Biological Mine    ( ποιξτσ)\n";
			else
				st2 = "\n";
			
			st3 = ".. MIRV Mine          (3 points)\n\n";
		}
		else
		{
			st1 = ".. Level 1 Mine        ( ποιξτ)\n.. Level 2 Mine       ( ποιξτσ)\n\n.. Concussion Mine     ( ποιξτ)\n.. Psionic Mine       ( ποιξτσ)\n";

			if (self.tp_grenades_1 == 5 || self.tp_grenades_2 == 5 || self.weapons_carried & 4096)
				st2 = ".. Napalm Mine        ( ποιξτσ)\n";
			else if (self.tp_grenades_1 == 13 || self.tp_grenades_2 == 13 || self.weapons_carried & 4)
				st2 = ".. Biological Mine    ( ποιξτσ)\n";
			else
				st2 = "\n";

			st3 = ".. MIRV Mine          ( ποιξτσ)\n\n";
		}
					
		st4 = "";
		st5 = "";
	}
	else // Specialist
	{
		if (!minesup)
		{
			header = "Σπεγιαμιστ:     ¨no mines up©\n\n";
		}
		else if (minesup == 1)
		{
			header = "Σπεγιαμιστ:      ¨1 mine up©\n\n";
		}
		else
		{
			header = "Σπεγιαμιστ:      ¨";
			tmp = ftos(minesup);
			header = strcat(header,tmp);
			header = strcat(header," mines up©\n\n");
		}
			
		if (points <= 0)
		{
			st1 = ".. Level 1 Mine        (1 point)\n.. Level 2 Mine       (2 points)\n.. Level 3 Mine       (3 points)\n\n.. Concussion Mine     (1 point)\n.. Psionic Mine       (2 points)\n";
			
			if (self.tp_grenades_1 == 5 || self.tp_grenades_2 == 5 || self.weapons_carried & 4096)
				st2 = ".. Napalm Mine        (3 points)\n";
			else if (self.tp_grenades_1 == 13 || self.tp_grenades_2 == 13 || self.weapons_carried & 4)
				st2 = ".. Biological Mine    (2 points)\n";
			else
				st2 = "\n";

			st3 = ".. MIRV Mine          (3 points)\n\n";
		}
		else if (points == 1)
		{
			st1 = ".. Level 1 Mine        ( ποιξτ)\n.. Level 2 Mine       (2 points)\n.. Level 3 Mine       (3 points)\n\n.. Concussion Mine     ( ποιξτ)\n.. Psionic Mine       (2 points)\n";
			
			if (self.tp_grenades_1 == 5 || self.tp_grenades_2 == 5 || self.weapons_carried & 4096)
				st2 = ".. Napalm Mine        (3 points)\n";
			else if (self.tp_grenades_1 == 13 || self.tp_grenades_2 == 13 || self.weapons_carried & 4)
				st2 = ".. Biological Mine    (2 points)\n";
			else
				st2 = "\n";

			st3 = ".. MIRV Mine          (3 points)\n\n";
		}
		else if (points == 2)
		{
			st1 = ".. Level 1 Mine        ( ποιξτ)\n.. Level 2 Mine       ( ποιξτσ)\n.. Level 3 Mine       (3 points)\n\n.. Concussion Mine     ( ποιξτ)\n.. Psionic Mine       ( ποιξτσ)\n";
			
			if (self.tp_grenades_1 == 5 || self.tp_grenades_2 == 5 || self.weapons_carried & 4096)
				st2 = ".. Napalm Mine        (3 points)\n";
			else if (self.tp_grenades_1 == 13 || self.tp_grenades_2 == 13 || self.weapons_carried & 4)
				st2 = ".. Biological Mine    ( ποιξτσ)\n";
			else
				st2 = "\n";
			
			st3 = ".. MIRV Mine          (3 points)\n\n";
		}
		else
		{
			st1 = ".. Level 1 Mine        ( ποιξτ)\n.. Level 2 Mine       ( ποιξτσ)\n.. Level 3 Mine       ( ποιξτσ)\n\n.. Concussion Mine     ( ποιξτ)\n.. Psionic Mine       ( ποιξτσ)\n";

			if (self.tp_grenades_1 == 5 || self.tp_grenades_2 == 5 || self.weapons_carried & 4096)
				st2 = ".. Napalm Mine        ( ποιξτσ)\n";
			else if (self.tp_grenades_1 == 13 || self.tp_grenades_2 == 13 || self.weapons_carried & 4)
				st2 = ".. Biological Mine    ( ποιξτσ)\n";
			else
				st2 = "\n";

			st3 = ".. MIRV Mine          ( ποιξτσ)\n\n";
		}
				
		st4="";
		st5="";

		bitfield = GetMineConvBitfield(self);

		if (!(bitfield & 1))
		if (self.no_grenades_1 >= 1)
		if (IsMineConvertible(self.tp_grenades_1))
		{
			st4 = ".. Convert ";
			tmp = GetGrenadeText(self.tp_grenades_1);
			st4 = strcat(st4,tmp);
			st4 = strcat(st4," Grenade");
			//st4 = padstr(st4,33);
			st4 = strcat(st4,"\n");
		}

		if (!(bitfield & 2))
		if (self.no_grenades_2 >= 1)
		if (IsMineConvertible(self.tp_grenades_2))
		{
			st5 = ".. Convert ";
			tmp = GetGrenadeText(self.tp_grenades_2);
			st5 = strcat(st5,tmp);
			st5 = strcat(st5," Grenade");
			//st5 = padstr(st5,33);
			st5 = strcat(st5,"\n");
		}
	}

	foot =	  "\n.. Ξοτθιξη                      \n\nΗυεςιμμα Ποιξτσ: ";
	
	tmp = ftos(points);
	foot = strcat(foot,tmp);
	foot = strcat(foot,"―");

	bitfield = GetMineSpentPoints(self);
	tmp = ftos(points + bitfield);
	foot = strcat(foot,tmp);
	
	CenterPrint7(self,header,st1,st2,st3,st4,st5,foot);
};

//======================================================================
// Guerilla menu handler

void(float inp) Menu_Guerilla_Input =
{
	if (inp == 10)
	{
		ResetMenu();
		self.impulse = 0;
	}

	// are we a specialist? if so.. we can convert grenades
	if (self.job & 131072)
	{
		local float convID;
		local float bitfield;

		bitfield = GetMineConvBitfield(self);

		if (inp == 8) // conversion of grenade 1
		{
			if (!(bitfield & 1))
			if (self.no_grenades_1 >= 1)
			if (IsMineConvertible(self.tp_grenades_1))
			{
				convID = ConvertGrenIDToMine(self.tp_grenades_1);
				GuerillaSetMine(convID,1);
			}
		}

		if (inp == 9) // conversion of grenade 2
		{
			if (!(bitfield & 2))
			if (self.no_grenades_2 >= 1)
			if (IsMineConvertible(self.tp_grenades_2))
			{
				convID = ConvertGrenIDToMine(self.tp_grenades_2);
				GuerillaSetMine(convID,2);
			}	 
		}
	}

	if (inp == 1)
		GuerillaSetMine(1,0);		
	else if (inp == 2)
		GuerillaSetMine(2,0);
	else if (inp == 3 && self.job & 131072)
		GuerillaSetMine(3,0);
	else if (inp == 4)
		GuerillaSetMine(4,0);
	else if (inp == 5)
		GuerillaSetMine(5,0);
	else if (inp == 6)
	{
		if (self.tp_grenades_1 == 5 || self.tp_grenades_2 == 5 || self.weapons_carried & 4096)
			GuerillaSetMine(7,0);
		else if (self.tp_grenades_1 == 13 || self.tp_grenades_2 == 13 || self.weapons_carried & 4)
			GuerillaSetMine(6,0);		 
	}
	else if (inp == 7)
		GuerillaSetMine(8,0);
		
	self.impulse = 0;
};

//======================================================================
// A mine blows up

void() GuerillaExplode =
{
	// Only call minedown() if we r still guerilla, this avoids garbage on clean up
	//if (self.owner.job & 32)
	if (self.owner.job & 64)
		MineDown(self.owner,self);

	local string st,st2;
	local float charged;
	
	if (time < self.heat + 8)
		charged = 0;
	else
		charged = 1;

	self.health = 0; //CH would cause tesla to act weird without
	
	if (self.has_sensor) // Standard mines
	{
		local float hitdamage, legdmg;
		local float joblevel;

		joblevel = GetJobExtras(self.owner);

		legdmg = 0;

		if (self.has_sentry == 1)
			hitdamage = 200;
		else if (self.has_sentry == 2)
		{
			hitdamage = 250;

			legdmg = 1;
			
			if (charged)
				SpawnSprite(1,2,self.origin,'0 0 0',1,0.1);
		}
		else
		{
			hitdamage = 300;

			legdmg = 2;
			
			if (charged)
				SpawnSprite(3,2,self.origin,'0 0 0',1,0.15);
		}

		deathmsg = 42;

		if (joblevel == 0)
		{
		  if (self.has_tesla == 2) // set by GuerillaSwep for trace weapons
			sprint(self.owner,2,"your mine is destroyed\n");

		  if (self.has_tesla == 0) // default 
			sprint(self.owner,2,"your mine explodes\n");
		
		  // if has_tesla is 1 print nothing, as this is set by DetonateMines() and GuerillaThink
		}
		else // specialist or technician
		{			 
			st = GetMineStr(self.has_sentry);
			st2 = "";

			if (self.has_holo)
				st2 = " converted";

			if (self.has_tesla == 2) // set by GuerillaSwep for trace weapons
				sprint(self.owner,2,"Your ",st,st2," mine is destroyed\n");
			
			if (self.has_tesla == 0) // default 
				sprint(self.owner,2,"Your ",st,st2," mine explodes\n");			 
		}

		if (!charged) //If not charged, do less damage when blowing up
		   T_RadiusDamage (self, self.owner, 60, world); //- damage was 80
		else 
		{
		   T_RadiusDamage (self, self.owner, hitdamage, world); //- damage was 160
		   
		   // legdamage for lvl2 and lvl3 mines if was hit from below (on ground usually)
		   if (legdmg)
		   {
			   local entity te;

			   te = findradius(self.origin, hitdamage + 15);
			   
			   while (te)
			   {
					if (te.classname == "player")
					if (CanDamage (te, self))
					if (te.health > 0)
					if (te.playerclass != 0)
					if (!Teammate(te.team_no,self.owner.team_no) || te == self.owner)
					if (!(te.invincible_finished > time))
					if (te.is_connected)
					if (!(te.armorclass & 4) || random() < 0.25) // blast armor avoids our legs to be hurt most of the time
					if (te.origin_z > self.origin_z) // only hurt legs if hit from below..
					{
						if (HurtLegs(te,legdmg))
						{
							if (legdmg == 2)
								sprint(te,2,"Woah! That mine really hurts your legs!\n");   
							else
								sprint(te,2,"That mine hurts your legs!\n");
						}
					}

					te = te.chain;
			   }
		   }
		}
		
		WriteByte (4, 23);
		WriteByte (4, 3);
		WriteCoord (4, self.origin_x);
		WriteCoord (4, self.origin_y);
		WriteCoord (4, self.origin_z);
	
		multicast (self.origin, 1);
		dremove(self);
	


	 }
	 else // Non-standard mines
	 {
		self.netname = "special_mine"; // avoids recursive calls and lets us identify mines vs grens
		self.touch = SUB_Null;
		self.think = SUB_Null;
		self.nextthink = -1;
		self.takedamage = 0; // NEEDED or crash

		st = GetMineStr(self.has_sentry);
		st2 = "";

		if (self.has_holo)
			st2 = " converted";

		if (self.has_tesla == 2) // set by GuerillaSwep for trace weapons
			sprint(self.owner,2,"Your ",st,st2," mine is destroyed\n");
			
		if (self.has_tesla == 0) // default 
			sprint(self.owner,2,"Your ",st,st2," mine explodes\n");
		
		if (!charged) // not armed?
		{
			WriteByte (4, 23);
			WriteByte (4, 3);
			WriteCoord (4, self.origin_x);
			WriteCoord (4, self.origin_y);
			WriteCoord (4, self.origin_z);
		
			multicast (self.origin, 1);
			dremove(self);
		


		}
		else // special mine is charged..
		{
			if (self.has_sentry == 4)
				ConcussionGrenadeExplode();
			else if (self.has_sentry == 5)
				PsionicGrenadeExplode();
			else if (self.has_sentry == 6)
				BioGrenadeExplode();
			else if (self.has_sentry == 7)
				NapalmGrenadeExplode();
			else if (self.has_sentry == 8)
				MirvGrenadeExplode();
			else if (self.has_sentry == 9)
				NailGrenadeExplode();
			else if (self.has_sentry == 10)
				GasGrenadeExplode();
			else if (self.has_sentry == 11)
				EMPGrenadeExplode();
			else if (self.has_sentry == 12)
				FragGrenadeExplode();
			else if (self.has_sentry == 13)
				KracGrenadeExplode();
			else if (self.has_sentry == 14)
				CaltropGrenadeExplode();
			else if (self.has_sentry == 15)
				AntiGravGrenadeExplode();
			else
			{
				RPrint("BUG: Unknown mine type on GuerillaExplode()!\n");
				dremove(self);
				return;
			}
		}
	 }
};

//=========================================================================
// Detonate all mines the mine_owner player entity has

void(entity mine_owner) DetonateMines =
{
	local entity e;
	local entity oself;

	oself = self;

	// Find any mine
	e = find(world, netname, "land_mine");
	
	while (e != world)
	{
	   if(e.classname == "grenade")
	   if(e.owner == mine_owner) {
		 /*e.heat = time;
		 e.has_tesla = 1; //- display no message on GuerillaExplode
		 e.think = GuerillaExplode;
		 e.nextthink = time;*/
		 self = e;
		 e.heat = time;
		 e.has_tesla = 1;
		 GuerillaExplode();
	   }
	   e = find(e, netname, "land_mine");
	}

	self = oself;
};

//====================================================
//Code to detonate the guerilla mines on traceattack weapons.
//Has small radius, just large enough to hit what was aimed at

void(vector startpos) GuerillaMineSweep =
{
	local entity head;
	head = findradius(startpos, 30);	
	while (head)
	{
		if (head.classname == "grenade" && head.netname == "land_mine") {
				  
		  head.has_tesla = 2; // "mine is destroyed" message on guerillaexplode()
		  head.think = GuerillaExplode;
		  head.nextthink = time + 0.1;				
				  
		}
		head = head.chain;
	}
};

//============================================================
// Think of mines, makes sound, scans and explodes if needed

void() GuerillaThink = //Every second see if we have enemy nearby
{
	if (!self.owner.is_connected)
	{
		dremove(self);
		return;
	}
	
	local entity head;
	local float finished; //Only blow up once
	
	if (self.has_fieldgen == 1)
	{
		self.effects = 0;
		self.has_fieldgen = 2;
		self.nextthink = time + 0.1;
		return;
	}
	if (self.has_fieldgen == 2)
	{
		self.effects = 8;
		self.has_fieldgen = 3;
		self.nextthink = time + 0.1;
		return;
	}
	if (self.has_fieldgen == 3)
	{
		self.effects = 0;
		self.has_fieldgen = 4;		  
	}
	
	finished = 0;
	
	self.nextthink = time + 0.6;
	
	if (time < self.heat + 8)
		return;
	
	if (time > self.last_attacked_time) {
		sound (self, 1, "weapons/guerblip.wav", 1, 2);
		self.last_attacked_time = time + 4;

		if (!self.has_fieldgen)
		{
			self.has_fieldgen = 1;
			self.effects = 8;
			self.nextthink = time + 0.1;
			return;
		}
	}

	local string desc, conv;
	local float hasextras;

	if (self.has_holo)
		conv = " converted";
	else
		conv = "";

	if (self.owner.job & 65536 || self.owner.job & 131072)
		hasextras = 1;
	else
		hasextras = 0;

	desc = GetMineStr(self.has_sentry);
	
	self.health = self.health - 1;

	if (self.health <= 0) { //Detonate mine cause we ran out of time

		local float minesup;

		minesup = GetMinesUp(self.owner);

		self.heat = time; //Make it a smaller explosion

		if (hasextras)
			sprint(self.owner,2,"Your ",desc,conv," mine runs out of energy, ");
		else
			sprint(self.owner,2,"Your mine runs out of energy, ");
		
		if (minesup > 1) {
		   local string st;
		   st = ftos (minesup - 1);
		   
		   if (self.owner.job & 65536 || self.owner.job & 131072)
		   {
			   sprint(self.owner,2,"you still have ");
			   sprint(self.owner,2,st);
			   sprint(self.owner,2," mines up\n");
		   }
		   else
		   {
			   sprint(self.owner,2,"you still have ");
			   sprint(self.owner,2,st);
			   sprint(self.owner,2,"/3 mines up\n");
		   }
		}
		else
		   sprint(self.owner,2,"you currently have no active mines\n");
		self.has_tesla = 1; //- display no message on GuerillaExplode
		GuerillaExplode();
		finished = 1;
	}
	head = findradius(self.origin,135);//OfN it was 150
	while (head != world && !finished) {

		if (((head.classname == "player" && head.playerclass != 0) || COOP_IsCoopMonster( head )) && head.health > 0) {






				//Mines detonate on either enemies or yourself
				if (CanDamage(head,self)) {
					if (!Teammate(head.team_no,self.owner.team_no) && head.undercover_team != self.owner.team_no)
					{						//Uncouvered ENEMY
						if (hasextras)
							sprint(self.owner,2,"your ",desc,conv," mine explodes on ");
						else
							sprint(self.owner,2,"your mine explodes on ");

						sprint(self.owner,2,head.netname);
						
						if (head.origin_z > self.origin_z)
							sprint(self.owner,2,"'s ass!\n");
						else
							sprint(self.owner,2,"'s face!\n");

						self.has_tesla = 1; //- display no message on GuerillaExplode
						GuerillaExplode();
						finished = 1;
					} else if (head == self.owner) { // ourselves
							
					   self.has_tesla = 1; //- display no message on GuerillaExplode
					   GuerillaExplode();
					   finished = 1;
					}
				}



		}
		else if (IsOwnedMonster(head) && !Teammate(head.real_owner.team_no,self.owner.team_no)) { //- OfN - monsters and grunt are affected
			T_Damage(head,self,self.owner,200); //Demons are vulnerable
			self.has_tesla = 1; //- display no message on GuerillaExplode
			GuerillaExplode();
			finished = 1;
		}
		head = head.chain;
	}
	//if (finished && self.has_sensor)
	//	dremove(self);
};

//================================================================
// What happens when someone runs it over

void() GuerillaTouch = 
{
	if (time < self.heat + 8)
		return;

	if (other.playerclass == 0) // skip Observers
		return;   

	
	if (other != self.owner)
	if (other.classname == "player" || IsMonster(other))	// Gizmo - allow non demons and non army soldiers to be affected (coop monsters)
	if (Teammate(self.owner.team_no,other.team_no))
	if (other.health > 0)
		return;
	

	if (other.classname == "player")
	if (other.health > 0)
	if (other.is_connected)
	{
		local string desc, conv;
		conv = "";
		desc = GetMineStr(self.has_sentry);

		if (self.has_holo)
			conv = " converted";

		if (self.owner.job & 65536 || self.owner.job & 131072)
			sprint(self.owner,2,other.netname," touches your ",desc,conv," mine!\n");
		else
			sprint(self.owner,2,other.netname," touches your mine!\n");
	}

	GuerillaExplode();
};

void() GuerillaTossTouch = 
{
	if (other != world) {
		GuerillaTouch();
		return;
	}

	if (pointcontents(self.origin) == -6 || pointcontents(self.origin) == -2) //CH if in wall or sky
	{
		self.health = 0; //CH needed for tesla
		// OfN CAUSES ANY PROBLEM? Is this needed?
				
		MineDown(self.owner,self);

		dremove(self);
		return;
	}

	self.angles = self.velocity = self.avelocity = '0 0 0';
	self.movetype = 0;
	sound (self, 1, "weapons/guerset.wav", 1, 1);
	self.touch = GuerillaTouch;
	self.think = GuerillaThink;
	self.nextthink = time + 1;
};

//==================================================================
// Called when a guerilla player uses 'skill'

void() JobGuerilla =
{
	if (self.job & 65536 || self.job & 131072)
	{
		if (self.current_menu == 31)
		{
			GuerillaSetMine(1,0);
			return; 
		}

		self.current_menu = 31;
		self.menu_count = 25; 
		return;
	}
	
	GuerillaSetMine(1,0);
};

//============================================================================
// Sets a mine of the specified kind

void(float minetype, float converted) GuerillaSetMine =
{
	if (!minetype) 
	{
		// if this gets executed its a bug
		RPrint("BUG: Invalid mine type on GuerillaSetMine()\n");
		return; 
	}
	
	if (!AttemptToSetMine(self,minetype,converted)) return;

	self.ammo_rockets = self.ammo_rockets - 4;
	self.job_finished = time + 4;
		
	if (self.job & 65536 || self.job & 131072)
	{
		local string st;
		st = GetMineStr(minetype);
		
		if (converted)
			sprint(self,2,"you convert a grenade into a ",st," mine...\n");		 
		else
			sprint(self,2,"you place a ",st," mine...\n");		
	}
	else
		sprint(self,2,"you place a mine...\n");

	if (self.current_menu == 31)
		ResetMenu();
	
	





	//Set all the critical crap on the mine
	newmis = spawn();
	newmis.movetype = 10;
	newmis.solid = 2;
	newmis.takedamage = 2;
	newmis.classname = "grenade";
	newmis.netname	 = "land_mine";
	//newmis.flags = #FL_FINDABLE_NONSOLID; // For mine ID
	//setsize (newmis, '-1 -1 0', '1 1 0.5');		
	setsize (newmis, '0 0 0','0 0 0');
	//setsize (newmis, '-0.5 -0.5 -0.5', '1 1 1');		
	setorigin (newmis, self.origin);
	newmis.owner = self;
	makevectors (self.v_angle);
	newmis.avelocity = '300 300 300';
	newmis.velocity = v_forward*600 + v_up * 200 + v_right*10 + v_up*10;
	newmis.angles = vectoangles(newmis.velocity);
	
	if (minetype == 7)
		newmis.skin = 2;
	else if (minetype == 8)
		newmis.skin = 0;
	else // default look
		newmis.skin = 1;

	//setmodel (newmis, "progs/lndmine.mdl");
	setmodel (newmis, "progs/biggren.mdl");

	newmis.heat = time; //Controls when mine can first go off
	newmis.has_tesla = 0; // OfN flag to Control what to sprint to owner of the mine when it exlodes
	newmis.last_attacked_time = time; // Controls beeps
	newmis.health = 360; //Max time for mine to live
	newmis.touch = GuerillaTossTouch;
	newmis.think = GuerillaThink;
	newmis.nextthink = time + 8;

	newmis.has_sentry = minetype;

	newmis.has_fieldgen = 0;

	if (minetype == 1 || minetype == 2 || minetype == 3)
		newmis.has_sensor = 1; // Standard mine
	else
		newmis.has_sensor = 0; // Non-standard mine

	newmis.has_holo = converted;

	MineUp(self,newmis);
};

//==============================================================================
// We have just killed some1 with our mines, award point/bonuses if appropiate

void(entity player) MineKill =
{
	if (!(player.job & 32))
	{
		//RPrint("BUG: Non-guerilla was in MineKill()!\n");
			// ^_^ not a bug, may happen on cleanup

		return;
	}
	
	// increase our mine kills counter
	player.dont_do_triggerwork = player.dont_do_triggerwork + 1;

	// award extra guerilla points if appropiate
	if (player.job & 65536 || player.job & 131072)
	{
		local float tfloat, tint, maxpoints, spent;

		tfloat = player.dont_do_triggerwork / 7;
		tint = floor(player.dont_do_triggerwork / 7);
		
		if (tfloat == tint)
		{
			tfloat = GetMineEarnedPoints(player);
			tint = GetMinePoints(player);
			spent = GetMineSpentPoints(player);
			maxpoints = GuerillaGetMaxPointsForJob(player);

			if ((tint + spent + 1) > maxpoints)
			{
				// Do nothing
			}
			else
			{
				sprint(player,2,"You have earned an extra guerilla point!\n");

				SetMinePoints(player, tint + 1);
				SetMineEarnedPoints(player, tfloat + 1);
			}
			
		}
	}

	if (extras_mode == 2)
		return;

	// reward with job extras
	if (player.dont_do_triggerwork == 20)
		GuerillaUpgradeJob(player);
	else if (player.dont_do_triggerwork == 36)
		GuerillaUpgradeJob(player);    
};

//====================================================================
// We use the 3 different bytes on .all_active field for the stuff

float(entity player) GetMineSpentPoints =
{
	return GetByte1(player.all_active);
};

float(entity player) GetMinePoints =
{
	return GetByte2(player.all_active);
};

float(entity player) GetMineEarnedPoints =
{
	return GetByte3(player.all_active);
};

void(entity player,float spentpoints) SetMineSpentPoints =
{
	player.all_active = AssignByte1(player.all_active,spentpoints);
};

void(entity player,float points) SetMinePoints =
{
	player.all_active = AssignByte2(player.all_active,points);
};

void(entity player,float points) SetMineEarnedPoints =
{
	player.all_active = AssignByte3(player.all_active,points);
};

//============================================================
// Returns an appropiate text for the given kind of gren

string(float typ) GetGrenadeText =
{
	local string st;

	if (typ == 1)
		st = "Normal";
	else if (typ == 2)
		st = "Concussion";
	else if (typ == 3)
		st = "Nail";
	else if (typ == 4)
		st = "Mirv";
	else if (typ == 5)
		st = "Napalm";
	else if (typ == 6)
		st = "Flare";
	else if (typ == 7)
		st = "Gas";
	else if (typ == 8)
		st = "EMP";
	



	else if (typ == 9)
		st = "Psionic";
	
	else if (typ == 10)
		st = "Fragmentation";
	else if (typ == 11)
		st = "KRAC";
	else if (typ == 14)
		st = "Caltrop";
	else if (typ == 13)
		st = "Biological";
	else if (typ == 12)
		st = "Antigrav";
	else st = "ERROR!";

	return st;
};

//====================================================================
// Returns TRUE if the specified gren type is "convertible" to a mine

float(float typ) IsMineConvertible =
{
	if (typ == 1)
		return 1;
	if (typ == 2)
		return 1;
	if (typ == 3)
		return 1;
	if (typ == 4)
		return 1;
	if (typ == 5)
		return 1;
	if (typ == 6)
		return 0;
	if (typ == 7)
		return 1;
	if (typ == 8)
		return 1;
	if (typ == 9)
		return 1;
	if (typ == 10)
		return 1;
	if (typ == 11)
		return 1;
	if (typ == 14)
		return 1;
	if (typ == 13)
		return 1;
	if (typ == 12)
		return 1;
	
	return 0;
};

//===========================================================================
// Gets the name of the given mine kind

string(float minetype) GetMineStr =
{
	if (minetype == 1)
		return "level 1";
	if (minetype == 2)
		return "level 2";
	if (minetype == 3)
		return "level 3";
	if (minetype == 4)
		return "concussion";
	if (minetype == 5)
		return "psionic";
	if (minetype == 6)
		return "biological";
	if (minetype == 7)
		return "napalm";
	if (minetype == 8)
		return "MIRV";
	if (minetype == 9)
		return "nail";
	if (minetype == 10)
		return "gas";
	if (minetype == 11)
		return "EMP";
	if (minetype == 12)
		return "fragmentation";
	if (minetype == 13)
		return "krac";
	if (minetype == 14)
		return "caltrop";
	if (minetype == 15)
		return "antigrav";
	 
	return "ERROR!";
};

//==========================================================
// Converts gren ID number into its corresponding mine ID

float(float grentype) ConvertGrenIDToMine =
{
	if (grentype == 1)
		return 1;
	if (grentype == 2)
		return 4;
	if (grentype == 3)
		return 9;
	if (grentype == 4)
		return 8;
	if (grentype == 5)
		return 7;
	if (grentype == 7)
		return 10;
	if (grentype == 8)
		return 11;
	if (grentype == 9)
		return 5;
	if (grentype == 10)
		return 12;
	if (grentype == 11)
		return 13;
	if (grentype == 14)
		return 14;
	if (grentype == 13)
		return 6;
	if (grentype == 12)
		return 15;
	
	return 0; // Bug if happens
};

//========================================================================
// The following funcs are used to update stuff when a mine goes down/up

void(entity player, entity mine) MineUp =
{
	






	
	local float minesup;
	
	minesup = GetMinesUp(player);

	if (mine.has_holo) // Converted grenade mine
	{
		local float bitfield;

		bitfield = GetMineConvBitfield(player);

		if (bitfield & mine.has_holo)
			RPrint("BUG: Double conversion of mine!\n"); // shouldnt happen

		bitfield = bitfield | mine.has_holo;

		SetMineConvBitfield(player,bitfield);

		if (mine.has_holo == 1)
		{
			if (!player.no_grenades_1)
				RPrint("BUG: MineUp() called with no grenades to be able to convert!\n");
			else
				player.no_grenades_1 = player.no_grenades_1 - 1;
		}
		else
		{
			if (!player.no_grenades_2)
				RPrint("BUG: MineUp() called with no grenades to be able to convert!\n");
			else
				player.no_grenades_2 = player.no_grenades_2 - 1;
		}
	}
	else // non-converted mine
	{	
		local float points;
		local float neededpoints;
		local float spent;

		points = GetMinePoints(player);
		neededpoints = MineNeededPoints(mine.has_sentry);
		
		if (neededpoints > points) // shouldnt happen
			RPrint("BUG: Points error in MineUp()!\n");
		
		// decrease our guerilla avaliable points
		SetMinePoints(player, points - neededpoints);

		// increase our spent points counter
		spent = GetMineSpentPoints(player);
		SetMineSpentPoints(player, spent + neededpoints);

		



















	}

	// increase our mine counter
	SetMinesUp(player, minesup + 1);
};

void(entity player, entity mine) MineDown =
{
	






	
	local float minesup;
	
	minesup = GetMinesUp(player);

	if (mine.has_holo) // converted grenade mine
	{
		local float bitfield;

		bitfield = GetMineConvBitfield(player);

		/*if (!(bitfield & mine.has_holo))
			RPrint("BUG: Wrong assignment of converted mine detected!\n"); // shouldnt happen*/

			// ^_^ this happens when CleanUpEverything() is called

		bitfield = bitfield - (bitfield & mine.has_holo);

		SetMineConvBitfield(player,bitfield);
	}
	else // non-converted mine
	{
		local float points;
		local float neededpoints;
		local float spent;

		points = GetMinePoints(player);
		neededpoints = MineNeededPoints(mine.has_sentry);
		
		// increase our guerilla avaliable points
		SetMinePoints(player,points + neededpoints);

		// decrease our spent points counter
		spent = GetMineSpentPoints(player);
		SetMineSpentPoints(player,spent - neededpoints);

		



















	}

	// decrease our mine counter
	SetMinesUp(player, minesup - 1);
};

//========================================================================
// Returns TRUE if able to set the specified mine, and reports if not

float(entity player, float minetype, float converted) AttemptToSetMine =
{	 
	local float minesup;
	
	minesup = GetMinesUp(player);
	
	// have we set too many mines already? (fixed max)
	if (minesup >= 5) 
	{
		sprint(player,2,"you can't set more than 5 mines!\n");
		
		player.job_finished = time + 1;
		return 0;
	}

	// not enough ammo for mine? (rockets)
	if (player.ammo_rockets < 4) 
	{
		sprint(player,2,"every mine needs 4 rockets to work!\n");		
		
		player.job_finished = time + 1;
		return 0;
	}	 

	// converted grenade?
	if (converted)
	{
		// we already have this mine up?
		local float bitfield;
		bitfield = GetMineConvBitfield(player);

		if (bitfield & converted)
			return 0;
		else
			return 1; //..ok, set mine		  
	}
	else // non-converted mines
	{
		if (player.job & 65536 || player.job & 131072)
		{
			local float points, neededpoints;

			points = GetMinePoints(player);
			neededpoints = MineNeededPoints(minetype);

			if (points < neededpoints)
			{
				sprint(player,2,"not enough guerilla points to set that mine!\n");
				return 0;
			}
			else
				return 1; //..ok, set mine
		}
		else // standard guerilla (no job extras)
		{
			if (minesup >= 3)
			{
				sprint(player,2,"you can set upto 3 mines!\n");
				return 0;
			}
			else
				return 1; //..ok, set mine
		}		 
	}

//comperr	return 0; // wont happen anyway..
};

//===========================================================
// Returns needed points for the given mine type

float(float minetype) MineNeededPoints =
{
	if (minetype == 1)
		return 1;
	if (minetype == 2)
		return 2;
	if (minetype == 3)
		return 3;
	if (minetype == 4)
		return 1;
	if (minetype == 5)
		return 2;
	if (minetype == 6)
		return 2;
	if (minetype == 7)
		return 3;
	if (minetype == 8)
		return 3;

	/*if (minetype == #MINE_NAIL)
		return ;
	if (minetype == #MINE_GAS)
		return ;
	if (minetype == #MINE_EMP)
		return ;
	if (minetype == #MINE_FRAG)
		return ;
	if (minetype == #MINE_KRAC)
		return ;
	if (minetype == #MINE_CALTROP)
		return ;
	if (minetype == #MINE_ANTIGRAV)
		return ;*/

	return 99; // bug if this value is taken into account	 
};

//==============================================================================
// Initializes guerilla points (MUST BE CALLED WITH NO MINES UP and only once)

void(entity player) GuerillaInit =
{
	player.all_active = 0; // first reset everything
	
	// then add the corresponding points
	if (player.job & 65536)
		SetMinePoints(player, 4);
	else if (player.job & 131072)
		SetMinePoints(player, 5);
	else SetMinePoints(player, 3);

	// also reset mines up flags and counter
	player.increase_team4 = 0;
};

//===========================================================================
// Functions to handle flags and variables on .increase_team4 field

float(entity player) GetMinesUp =
{
	return GetByte1(player.increase_team4);
};

void(entity player, float minesup) SetMinesUp =
{
	player.increase_team4 = AssignByte1(player.increase_team4,minesup);
};

float(entity player) GetMineConvBitfield =
{
	return GetByte2(player.increase_team4);
};

void(entity player, float bitfield) SetMineConvBitfield =
{
	player.increase_team4 = AssignByte2(player.increase_team4,bitfield);
};

//=================================================================
// Returns the max number of points the player may have by job

float(entity player) GuerillaGetMaxPointsForJob =
{
	if (player.job & 32)
	{
		if (player.job & 131072)
			return 10;
		else if (player.job & 65536)
			return 8;
		else 
			return 3;
	}
	else 
		return 0;
};

//==================================================================
// Upgrades job, called from MineKill() if needed

void(entity player) GuerillaUpgradeJob =
{
	local float currentpoints, spent;

	if (player.job & 131072)
		return; // cant upgrade anymore
	 
	if (player.job & 65536)
	{
		sprint(player,2,"You are now a guerilla specialist!\n");

		player.job = (player.job | 131072) - 65536;

		// adjust points if needed and for sanity
		spent = GetMineSpentPoints(player);
		currentpoints = GetMinePoints(player) + spent;
		
		if (currentpoints < 5)
		{
			SetMinePoints(player, 5 - spent);
			currentpoints = GetMinePoints(player);
		}

		if (currentpoints > 10)
			SetMinePoints(player, 10 - spent);			  
	}
	else // no extras
	{
		sprint(player,2,"You have become a guerilla technician!\n");

		player.job = player.job | 65536;

		// adjust points if needed and for sanity
		spent = GetMineSpentPoints(player);
		currentpoints = GetMinePoints(player) + spent;
		
		if (currentpoints < 4)
		{
			SetMinePoints(player, 4 - spent);
			currentpoints = GetMinePoints(player);
		}

		if (currentpoints > 8)
			SetMinePoints(player, 8 - spent);			  
	}
};

//=================================================================
// returns the total points a player has (avaliable+spent)

/*float(entity player) GuerillaGetTotalPoints =
{
	local float spent, avail;
	avail = GetMinePoints(player);
	spent = GetMineSpentPoints(player);

	return spent + avail;
};*/

